[{"content":"因為 DP 是面試常遇到的問題，此文會從 DP 演算法的演化開始解釋，並說明如何優化時間與空間複雜度，最後以如何識別題型、尋找 DP 關注點、程式模板結尾。\n當 backtracking TLE DP 應用的場景很多。一開始的概念是由 backtrack 方法而生，由於 backtrack 會將所有可能性遍歷，其中的很多 path 會被重複計算，為了節省效率、不重複計算，我們可以將部分計算結果記起來，當需要參照時，只需要直接查表即可。\n讓我們首先回顧 backtrack 的概念\n1 2 3 4 5 6 7 8 backtrack(參數) { if 終止條件 { 保存結果; return } for 選擇 in 選擇列表 { 做選擇 backtrack(新參數) 撤銷選擇 } } 746. Min Cost Climbing Stairs You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\nYou can either start from the step with index 0, or the step with index 1.\nReturn the minimum cost to reach the top of the floor.\nExample 1:\nInput: cost = [10,15,20] Output: 15\nExplanation: You will start at index 1. Pay 15 and climb two steps to reach the top. The total cost is 15.\n以這題為例，若使用 backtracking 的話就是每一次都去回溯前一步與前兩步，然後取其小值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func minCostClimbingStairs(cost []int) int { n := len(cost) var backtrack func(i int) int backtrack = func(i int) int { if i \u0026gt;= n { // base condition return 0 } oneStep := cost[i] + backtrack(i+1) twoSteps := cost[i] + backtrack(i+2) return min(oneStep, twoSteps) } return min(backtrack(0), backtrack(1)) } 空間複雜度: O(n)\n時間複雜度: O(2n) 因為每個位置都有兩個選擇：爬一階或兩階，因此會長成一棵高度為 n 的二元決策樹，總共的 path 在每一個節點都是兩者擇一，因此來到了 2n 的時間複雜度。\n視覺化的話可以看到中間的階梯「到2」、「到3」、「到4」都被重複計算了很多次!\n1 2 3 4 5 6 7 8 9 10 cost = [10, 15, 20, 25] 起點 / \\ 從0開始(10) 從1開始(15) / \\ / \\ 到1(15) 到2(20) 到2(20) 到3(25) / \\ / \\ / \\ / \\ 到2 到3 到3 到4 到3 到4 到4 到5 (20) (25) (25) (25) Memoization (top-down) 承上所說，我們想把重複的部分紀錄起來，因此宣告一個 array 名為 memo，memo[i] 紀錄到達第 i 階的最小步數。如果 memo[i] 沒有資料才需要計算，並且在計算完後把 data 存起來！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func minCostClimbingStairs(cost []int) int { n := len(cost) memo := make([]int, n) for i := range memo { memo[i] = -1 } var dp func(i int) int dp = func(i int) int { if i \u0026gt;= n { return 0 } // 如果已經計算過,直接返回記錄的結果 if memo[i] != -1 { return memo[i] } // 計算並記錄結果 oneStep := cost[i] + dp(i+1) twoSteps := cost[i] + dp(i+2) memo[i] = min(oneStep, twoSteps) return memo[i] } return min(dp(0), dp(1)) } 複雜度分析 時間複雜度: O(n) 共會計算 n 次，因為重複的部分透過 O(1) 的時間複雜度直接查。\n空間複雜度: O(n) 使用到額外的 memo array O(n) 與 stack 大小 O(n)，O(2n)=O(n)\n在此可以注意到，如果我們想要降低空間複雜度，首當其要是把遞迴改成迴圈，誠如 backtracking 遇到的情況。\nBottom-Up DP 核心思路為從最簡單的子問題開始，逐步構建到完整問題的解。以同樣的一題，定義 dp[i] 為到達第 i 階的最小成本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func minCostClimbingStairs(cost []int) int { n := len(cost) dp := make([]int, n+1) // base condition dp[0] = 0 dp[1] = 0 for i := 2; i \u0026lt;= n; i++ { dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]) } return dp[n] } 狀態轉移方程 1 dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) 在這邊有一句很重要的程式，決定了 dp 表格是如何一步步建構起來。我們命名為狀態轉移方程。\n什麼是「狀態」 狀態就是在解決問題的某個時刻，我們需要知道的所有關鍵資訊。想像你在玩一個遊戲，狀態就像是遊戲的「存檔點」：\n你在哪裡？（位置） 你有什麼？（資源） 你做過什麼？（歷史） 以 Min Cost Climbing Stairs 這題為例： 問題：要爬到樓梯頂部\n可能的狀態定義方式：\n方式 1 -\u0026gt; 上面的程式採用\n狀態 = \u0026ldquo;我現在站在第 i 階\u0026rdquo;\n記錄 = \u0026ldquo;到達第 i 階的最小成本\u0026rdquo;\n方式 2 -\u0026gt; 也可以\n狀態 = \u0026ldquo;我要從第 i 階出發\u0026rdquo;\n記錄 = \u0026ldquo;從第 i 階到頂部的最小成本\u0026rdquo;\n方式 3 -\u0026gt; 太複雜！不需要記錄這麼多\n狀態 = \u0026ldquo;我在第 i 階，而且我是從第 j 階來的\u0026rdquo;\n記錄 = \u0026ldquo;到達第 i 階並且上一步在第 j 階的最小成本\u0026rdquo;\n什麼是「狀態轉移」 狀態轉移就是從一個狀態到另一個狀態的變化規則。就像遊戲中的「行動規則」：\n我在 A 點，可以做什麼動作到達 B 點？ 這個動作的代價是什麼？\n通用形式：\n1 dp[當前狀態] = function(dp[之前的狀態們], 當前決策) 逐項解釋的話，這裡的狀態是這樣轉移的\n1 2 3 4 dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) ↑ ↑ ↑ | | | 函數 從i-1來的路徑 從i-2來的路徑 決策流程圖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 開始 ↓ 問題：我要求什麼？ （最大值、最小值、方案數、是否可行...） ↓ 確定目標狀態 （通常是最後一步、終點、目標數值） ↓ 反推：達到目標需要什麼資訊？ ↓ 這些資訊會隨著什麼改變？ （位置、時間、剩餘資源...） ↓ 能否用簡單的變數表達這些變化？ ├─ 是 → 這就是你的狀態定義 └─ 否 → 需要更多維度或重新思考 再次使用這題為例：\n我要求什麼？ 答：到達樓梯頂部的最小成本\n目標狀態－樓梯頂部是什麼？ 答：第 n 階（cost 陣列長度之後）\n到達第 n 階需要什麼資訊？ 答：我需要知道到達前面各階的成本\n這些資訊隨什麼改變？ 答：隨著樓梯的階數 i 改變\n如何表達？ 答：dp[i] = 到達第 i 階的最小成本\n如此一來，就可以找到正確的狀態轉移程式！\n空間優化 終於來到最後一步！觀察狀態轉移方程，發現 dp[i] 只依賴於 dp[i-1] 和 dp[i-2]，所以不需要保存整個陣列，只需要保存最近的兩個值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func minCostClimbingStairs(cost []int) int { n := len(cost) // 只需要保存兩個狀態 // prev2: 代表 dp[i-2] // prev1: 代表 dp[i-1] prev2 := 0 // dp[0] prev1 := 0 // dp[1] for i := 2; i \u0026lt;= n; i++ { current := min(prev1+cost[i-1], prev2+cost[i-2]) // 滑動窗口:更新兩個變數 prev2 = prev1 prev1 = current } // prev1 現在儲存的是 dp[n] return prev1 } 複雜度分析 時間複雜度: O(n)\n空間複雜度: O(1)\n只使用了固定數量的變數(prev2, prev1, current)，不隨輸入大小增長\n結論 —— DP 通用解題框架 遞迴 → 遞迴+記憶化 → DP → 空間優化 DP\n步驟 1: 識別 DP 問題特徵\n✓ 有最優子結構(大問題的最優解包含子問題的最優解) ✓ 有重疊子問題(相同的子問題被多次求解) ✓ 需要求最優解(最大值、最小值、最長、最短等) 步驟 2: 定義狀態: \u0026ldquo;我需要記錄什麼資訊來解決問題?\u0026rdquo;\n步驟 3: 找出狀態轉移方程: \u0026ldquo;當前狀態如何從之前的狀態推導?\u0026rdquo;\n步驟 4: 確定基礎情況: \u0026ldquo;最簡單的情況是什麼?\u0026rdquo;\n步驟 5: 決定計算順序\nTop-Down: 從目標開始,遞迴到基礎情況 (需要 memoization) Bottom-Up: 從基礎情況開始,迭代到目標 (通常更高效) 步驟 6: 空間優化 (如果可能)\n","date":"2025-11-12T17:28:42+01:00","permalink":"https://miyaya.github.io/p/dp-%E8%88%87%E7%8B%80%E6%85%8B%E8%BD%89%E7%A7%BB/","title":"DP 與狀態轉移"},{"content":"同樣的，今天的文章也是《跟著 Docker 隊長，修練 22天就精通》的讀書筆記，內容包含了第 3、4 章。\n建立容器映像檔 Docker 根據 Dockerfile 的設定，將程式打包成一個映像檔。打包的時候，需要提供映像檔的名字，以及存在哪裡，--tag 用來設定映像檔的名稱。\n1 docker image build --tag web-ping . # . 代表存在當前的目錄 接著就會一行一行的根據 dockerfile 的設定將目前的目錄 (context) 送到 Docker daemon 然後建置起來！\n環境變數 我們可以在執行容器的時候透過指令 --env 或是 -e 改變環境變數。以書裡的例子，這邊 ping 的對象被設定為 google.com\n1 docker container run --env TARGET=google.com diamol/ch03-web-ping 本機端會有一組預設環境變數，但這並不影響我們想要在容器內設定自定義的環境變數，換句話說，當同時執行兩個不同的容器，環境變數也可以分別設定。這是容器帶來的其中一個好處，將環境乾淨分割。\nDockerfile 透過 dockerfile，應用程式具備可移植性。不管在哪裡的容器都可以執行該應用程式，build server 只需要安裝 docker 就可以同步不同硬體條件中的開發環境。\nDockerfile 沒有副檔名，裡面常用的命令包含 FROM, ENV, WORKDIR, COPY, CMD:\nFROM 載入映像檔 ENV 以 key-value 的形式設置環境變數 WORKDIR 在映像檔系統中根據作業系統建立一個目錄，並設定為工作目錄 COPY 把檔案從本機複製到映像檔裡頭 CMD 在容器啟動時自動執行 RUN 在容器裡執行命令，命令的結果會留在映像層 書裡的範例如下\n1 2 3 4 5 6 7 8 9 10 # 以 diamol/node 作為基底映像檔，因為 diamol/node 安裝了執行該專案所需的 node.js 環境 FROM diamol/node ENV TARGET=\u0026#34;blog.sixeyed.com\u0026#34; ENV METHOD=\u0026#34;HEAD\u0026#34; ENV INTERVAL=3000 WORKDIR /web-ping COPY app.js . CMD [\u0026#34;node\u0026#34;, \u0026#34;/web-ping/app.js\u0026#34;] 多階段 Dockerfile 有的程式經歷多個階段才可以完成建置映像檔，每個階段都會由 FROM 開頭、並可以使用 AS 來命名。\n書裡的範例包含了三個階段，雖然每個階段都是獨立執行，但可以把前一個階段的結果（檔案與目錄）複製起來。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # build-stage FROM diamol/base AS build-stage RUN echo \u0026#39;Building...\u0026#39; \u0026gt; /build.txt # test-stage FROM diamol/base AS test-stage COPY --from=build-stage /build.txt /build.txt RUN echo \u0026#39;Testing...\u0026#39; \u0026gt; /build.txt # final FROM diamol/base COPY --from=test-stage /build.txt /build.txt CMD cat /build.txt 我們可以從 docker hub 裡找到自己專案所需的映像檔當作基礎檔案，像是帶有建置工具的、或是帶有 runtime 環境的映像檔。\n多階段的建置也可以優化 CI/CD pipeline，如每個階段只需要複製該階段需要的文件、測試的內容與工具不會進入 production\u0026hellip;等。透過這樣的操作，不但可以減少最後映像檔的大小、縮短啟動時間，映像檔中使用到的軟體更少也可以有效減少漏洞攻擊的風險。\n如 java 的建置過程中，最終會把編譯好的 JAR 檔拿出來寫入映像檔，但使用直譯語言 JS 的 node.js 專案就會將執行環境與程式碼放入映像檔中。\n映像層 Image Layers 當我們從 docker hub 下載 (pull) 一個映像檔時，會看到有很多檔案被下載下來，這些檔案被存在 Docker engine 快取裡。每個檔案分別是一個映像層。\n一個映像檔會分成一層層的映像層，組裝在一起才是完整的容器檔案。這麼做的目的是當有很多個 share 相同環境的容器時，可以共用底層的映像層。像是前面指令的 FROM diamol/node 提供了一個 base OS 層與一個 node js 映像層。這樣的好處是當有很多檔案時，磁碟使用空間可以被節省起來。這些共用的映像層會被設為唯讀，以防修改後其他映像檔沒辦法使用。\n使用 history 指令，可以看到映像檔的 metadata\n1 docker image history web-ping 優化 Dockerfile 每一個 Dockerfile 的指令，會各自對應到一層映像層。在建置的時候，當修改了一個命令，這個命令以前的都需要重新執行。\n因此可以使用這個映像層快取的特性來優化，以節省時間。不常改的放前面，常常改的放後面。\n以剛剛的範例來說，可以優化成如下\n1 2 3 4 5 6 7 8 9 10 FROM diamol/node CMD [\u0026#34;node\u0026#34;, \u0026#34;/web-ping/app.js\u0026#34;] ENV TARGET=\u0026#34;blog.sixeyed.com\u0026#34; \\ METHOD=\u0026#34;HEAD\u0026#34; \\ INTERVAL=3000 WORKDIR /web-ping COPY app.js . 這樣一來，假設修改了 app.js 再重新 build，除了最後一層，其他都會使用快取的方式執行。\n分散式應用程式 完整的應用程式通常會需要整合多個容器，如網頁服務，後端是一個應用程式、前端是一個、log 也可以是一個獨立的服務，那就會有好幾個容器彼此獨立運作並透過 docker 提供的虛擬網路互相溝通。\nDocker 虛擬網路 docker 在建立容器時會自動分配虛擬 IP 地址。我們可以使用 docker network create nat 來創造一個虛擬網路，或是在執行容器時使用參數 --network 將容器連接到虛擬網路，該網路上的任何容器就可以依據容器名稱互相溝通。\n1 docker container run --name iotd -d -p 800:80 --network nat image-of-the-day 這個指令啟動一個容器並命名為 iotd 然後於後台持續 (-d) 執行 image-of-the-day 這個映像檔。接著把容器的連接埠 80 連接到本機 port 800，把服務連到 docker 提供的虛擬網路 nat 上，也就是說從本機打開 localhost:800 可以訪問容器的服務。\n總複習 目前學到最基本最基本的指令包含跟容器相關的 docker container、跟映像檔相關的 docker image、建置映像檔需要的 docker build、以及最終在容器執行映像檔的 docker run。\nlab 4 這個階段要把以下 dockerfile 優化\n1 2 3 4 5 6 7 8 9 10 11 12 FROM diamol/golang:2e WORKDIR /web COPY index.html . COPY go.mod main.go /web/ RUN go build -o /web/server RUN chmod +x /web/server CMD [\u0026#34;/web/server\u0026#34;] ENV USER=sixeyed EXPOSE 80 首先，我們可以先把單一階段分段成多階段 build：此處可以分成 build 跟 run。接著，為了最佳化最終的 image size，我們可以觀察有哪些東西是只在建構階段需要，就可以從 run 階段移除，只保留所需最小環境。這邊有一個小細節，diamol/golang:2e 就包含了完整 go 的工具庫，當在執行階段時可以改用 diamol/base:2e 以縮小映像檔尺寸。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # build FROM diamol/golang:2e AS builder COPY go.mod main.go /go/ RUN go build -o /server RUN chmod +x /server # production FROM diamol/base:2e EXPOSE 80 CMD [\u0026#34;/web/server\u0026#34;] ENV USER=\u0026#34;sixeyed\u0026#34; WORKDIR /web COPY --from=builder /server . COPY index.html . 另外， go image 的預設工作目錄是 /go，也就是說當執行 RUN go build 時，預設的 WORKDIR=/go/。優化後的文件結構是把需要編譯的檔案複製到 /go/ 目錄下，Go 編譯器就可以找到 go.mod，不需要另外宣告 WORKDIR。\n優化前的映像檔大小約 450 MB\n1 2 3 miyalee@miyademac-mini lab % docker image ls -f reference=lab REPOSITORY TAG IMAGE ID CREATED SIZE lab latest a3ad6162d530 2 minutes ago 453MB 優化後縮減至僅剩 35MB !!!\n1 2 3 miyalee@miyademac-mini lab % docker image ls -f reference=lab REPOSITORY TAG IMAGE ID CREATED SIZE lab latest f50f30c100ec 7 seconds ago 35.2MB 我們前面還有提到映像層會快取起來，當有文件修改時，對應到的那一層以及其之後的每一層會重新 build，因此我們會盡可能希望把常常改動的部分放到比較後面的階段。\n假設對 index.html 有所修改，在初始版本的 dockerfile 中，從 COPY index.html .開始算共有 7 個步驟被影響，無法使用快取。而後面的優化版本，我們把 COPY index.html . 放到了最後，因此只有一個步驟需要重新執行。\n","date":"2025-11-11T18:20:36+02:00","permalink":"https://miyaya.github.io/p/docker-%E6%98%A0%E5%83%8F%E6%AA%94/","title":"Docker 映像檔"},{"content":"NeetCode 250 上次找實習的時候因為覺得時間沒有很夠，所以刷了 Blind 75 就上戰場了 XD 不過事實證明只要有運氣，刷題可能不是那麼重要(並不是)\n這次因為不想經歷刷題的時候很痛苦的過程，想要尋找一種輕鬆刷題的途徑，覺得 NeetCode 250 好像是一個很不錯的組合！由 NeetCode 150 + 100 題 easy / medium 組成，我覺得更能幫助在練習的過程中訓練信心 XDD\n沿著 roadmap 慢慢寫，今天來到了 backtracking，算是為 graph 與 dp 做第一步的準備。\nBacktracking 終極模版 backtracking 因為是某種程度的暴力解法（就真的需要遍歷），所以相對來說寫法跟演算法都蠻單純的，只需要注意終端條件與一些小細節，如排序後可以提早跳出迴圈等優化。\n1 2 3 4 5 6 7 8 backtrack(參數) { if 終止條件 { 保存結果; return } for 選擇 in 選擇列表 { 做選擇 backtrack(新參數) 撤銷選擇 } } 組合 Combination 模板 以 1863. Sum of All Subset XOR Totals 來看，每個元素有 2 種選擇（拿或不拿），當我 index 指標走到最後一個的時候代表比完了，可以把數字加總起來。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var backtrack func(index int, currentXOR int) backtrack = func(index int, currentXOR int) { // 遞迴結束條件 if index == len(nums) { totalSum += currentXOR return } // 不選當前元素 backtrack(index+1, currentXOR) // 選擇當前元素 backtrack(index+1, currentXOR ^ nums[index]) } 複雜度分析 時間複雜度: O(2^n) 因為前面提到每個元素有拿或不拿，且進行 XOR 計算的複雜度為 O(1)。 空間複雜度: O(n) 因為遞迴迭代的 stack 深度為 N。\n去重 如 40. Combination Sum II 中的測資 candidates = [2,5,2,1,2], target = 5。\n首先我們先排序，那 candidates = [1,2,2,2,5]，如果沒有去重的話，最後的結果會變成\n1 2 3 4 5 6 7 result = [ [5], // ✓ 正確 [1,2,2], // ✓ 正確 [1,2,2], // ❌ 重複! (來自索引 0,1,2) [1,2,2], // ❌ 重複! (來自索引 0,1,3) [2,2,2], // ❌ 錯誤! sum=6 \u0026gt; 5 ] 當我們在元素有重複的情況下，會需要加上這一段程式碼去重：避免如果把當前的 2 拿來用，且前一個元素也是 2 而發生重複的情況\n1 2 3 if j \u0026gt; i \u0026amp;\u0026amp; candidates[j] == candidates[j-1] { continue } 注意這邊的跳過，是指「只跳過同一層的重複」！\n「不同層」使用相同數字，依然是合法的！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 [] (start=0, sum=0) | ┌─────────────────┼─────────────────┬─────────┐ ↓ ↓ ↓ ↓ [1] [2] [2]跳過 [2]跳過 [5] (start=1) (start=2) (j=2) (j=3) (start=5) sum=1 sum=2 ↑ ↑ sum=5 ✓ | | | | | | 因為 j \u0026gt; start(0) | | 且 [2]==[1]? No | | 且 [2]==[2]? Yes! 跳過 ┌───┼───┬───┐ ┌───┼───┬───┐ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [1,2][1,2][1,2][1,5][2,2][2,2][2,5] 跳過 跳過 跳過 s=3 (j\u0026gt;2)(j\u0026gt;2) s=6 s=4 (j\u0026gt;3) s=7 i=2 且==[2] 且==[2] i=3 且==[2] | | ↓ ↓ [1,2,2] [2,2,2] s=4 s=6 i=3 (超過target) | ↓ [1,2,2,2] 跳過 [1,2,2,5] s=6 s=9 (超過) (超過) 排列 Permutation 在排列問題中，通常會需要遍歷所有的可能性，透過 backtracking implement 以下的流程，可以系統性地探索所有可能性：\n選擇 (Choose): 做出一個選擇 探索 (Explore): 遞歸探索該選擇的後果 撤銷 (Unchoose): 撤銷選擇,嘗試其他可能性 以 [1,2,3] 這個簡單的例子來說，就會是這樣的流程\n1 2 3 4 5 6 7 8 選擇 1 → path = [1] 選擇 2 → path = [1, 2] 選擇 3 → path = [1, 2, 3] ✓ 找到一個排列! 回溯: 撤銷 3 → path = [1, 2] 沒有更多選擇,回溯: 撤銷 2 → path = [1] 選擇 3 → path = [1, 3] 選擇 2 → path = [1, 3, 2] ✓ 找到一個排列! ... 繼續直到所有分支探索完畢 模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func backtrack(nums []int, path []int, used []bool, result *[][]int) { // Base Case: 當路徑長度等於原數組長度時,找到一個完整排列 if len(path) == len(nums) { // 重要!必須創建新切片,否則後續修改會影響已保存的結果 temp := make([]int, len(path)) copy(temp, path) *result = append(*result, temp) return } // 遞迴情況: 嘗試每一個未使用的數字 for i := 0; i \u0026lt; len(nums); i++ { if used[i] { continue } // 1. 做選擇 (Choose) path = append(path, nums[i]) used[i] = true // 2. 遞歸探索 (Explore) backtrack(nums, path, used, result) // 3. 撤銷選擇 (Unchoose) - 回溯的關鍵步驟! path = path[:len(path)-1] used[i] = false } } 複雜度分析 時間複雜度: O(n! × n)\nn! 種排列組合 (n 個元素的全排列數) 每個排列需要 O(n) 時間複製到結果中 空間複雜度: O(n)\n遞迴調用棧深度: O(n) path 數組: O(n) used 數組: O(n) 進階版: 含重複元素的排列 這個版本中，最重要的邏輯是要避免重複排列，而去重邏輯依賴於相鄰重複元素，所以首先要先排序，之後遞迴的時候才能正確識別和跳過重複元素。\n1 2 3 4 5 6 7 8 9 [] ┌────────┼────────┐ 1₁ 1₂(跳過) 2 ┌──┴──┐ │ 1₂ 2 1₁,1₂ │ │ ┌─┴─┐ 1₂,2 1₁,1₂ 1,1,2 1,2,1 │ │ (跳過) [1,1,2] [1,2,1] [2,1,1] 以上面的例子來看的話，1₂ 在同層出現時，1₁ 還沒被使用(used[0]=false)的話則跳過 1₂，就可以避免有重複的 [1,1,2], [1,2,1] 結果。\n1 2 3 4 5 // 如果當前元素與前一個元素相同,且前一個元素未被使用,則跳過 // 這確保相同元素按順序使用,避免重複排列 if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1] { continue } 結語 - 排列 vs 組合 跟 combination 相比，因為 permutation 不是線性的遍歷，因此需要去記得是否該元素有被使用過 used。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // 排列問題需要遍歷所有的順序，因此不能限定單一的線性方向 func permuteCorrect(nums []int) [][]int { result := [][]int{} path := []int{} used := make([]bool, len(nums)) var backtrack func() backtrack = func() { if len(path) == len(nums) { temp := make([]int, len(path)) copy(temp, path) result = append(result, temp) return } for i := 0; i \u0026lt; len(nums); i++ { // ✅ 從 0 開始! if used[i] { continue } path = append(path, nums[i]) used[i] = true backtrack() // ✅ 不傳 start! path = path[:len(path)-1] used[i] = false } } backtrack() return result } // 組合問題就可以用 start 把搜尋範圍限定在當前元素之後，去避免會有重複的可能性 func combine(nums []int, k int) [][]int { result := [][]int{} path := []int{} var backtrack func(start int) backtrack = func(start int) { if len(path) == k { temp := make([]int, len(path)) copy(temp, path) result = append(result, temp) return } for i := start; i \u0026lt; len(nums); i++ { // ✅ 組合可以用 start! path = append(path, nums[i]) backtrack(i + 1) path = path[:len(path)-1] } } backtrack(0) return result } ","date":"2025-10-15T01:37:55+02:00","permalink":"https://miyaya.github.io/p/neetcode250-%E9%80%B2%E5%BA%A620-backtracking-%E8%88%87%E6%8E%92%E5%88%97%E7%B5%84%E5%90%88/","title":"NeetCode250 進度20% - Backtracking 與排列組合"},{"content":"之前的工作有碰過 Kubernetes (k8s)，不過對底層技術與實作並不熟悉，當時有主管帶著我飛因此天不怕地不怕。如今換了工作，目前的公司有超多 legacy code，很多軟硬體都偏老舊，算是我們還在數位轉型的階段，因此 dockerize 技術某種程度上變成了必要條件。在我前一份工作，我就對這個很感興趣，雖然目前不再是 devops，不知道目前的工作會不會有直接派上用場的機會，但總覺得學了準沒錯。\n因此在最愛的天瓏書店購入了《跟著 Docker 隊長，修練 22天就精通》，結果第二章就覺得有點硬 XD 不做筆記的話會忘記。另外一提，作者是 Docker 技術的推廣者之一，還製作了與章節同步的教學影片，真的是佛心來著。（不過天知道我哪天為有閒有情致來看）\n基本語法 docker run 書裡的第一個語法是 docker run diamol/ch02-hello-diamol，但因為地端沒有這個映像檔，因此會去 Docker hub 下載。這是一個雲端倉庫服務，有點像 git clone 的感覺。\n而一開始安裝的 Docker desktop 是用來提供本地 docker 環境、執行容器與管理地端映像檔的工具。當第一次執行 docker run 時，Docker desktop 會自動從 Docker hub 下載 image 檔案到本地，然後再執行容器。\n如果想提供參數，--tty 或是簡寫 -t，用來分配一個偽終端機 (pseudo-TTY)，讓容器內的程式認爲他正在跟真實的終端機互動，提供像是彩色字體跟格式化的顯示，也支援互動性。通常會跟 --interactive 或 -i 共用，也可以再簡寫為 -it。想要跳出容器的終端機對話視窗時，只需要按 ctl+D 或是直接輸入指令 exit 即可。\ndocker container exec {CONTAINER ID} ... 也可以進入容器 shell 執行指令\n最後，可以透過更多參數在容器中執行一個網站\n1 docker container run --detach --publish 8088:80 diamol/ch02-hello-diamol-web --detach 代表在背景啟動容器並顯示容器 ID，所以執行後會看到一串很長的 ID --publish 8088:80 配發值記得網路連接 port 給容器使用，也就是對外的公開 port 是 8088 但容器內部的 port 是 80 而容器跟實際電腦的 IP 也不一樣，每個容器都有自己專屬的 IP，也就是 docker 裡頭建立的虛擬 IP。電腦的 IP 是在連接 router 時分配到的，而容器的虛擬網路 IP 是 docker 分配的。所以電腦並不能直接連接到容器，而是要透過這個虛擬的 port 把流量轉到容器中。雖然瀏覽器連到的網址 localhost:8088 是地端電腦提供的，但網站內容是容器提供的，驗證了打包在容器裡的應用程式可以很容易被移植！｡:.ﾟヽ(*´∀`)ﾉﾟ.:｡\ndocker container ls 使用這個指令可以看目前哪些容器正在執行，在 docker 指令操作時就是透過這邊的 CONTAINER ID 來進行辨識。\n不過 CONTAINER ID 不需要全打，只要打部分就可以 (如前面兩個字)。\n如果想要看完整的容器，包含已經 exited 的，可以加上參數 --all\ndocker container top {CONTAINER ID} 印出某個指定容器的 process\ndocker container logs {CONTAINER ID} docker 會把應用程式的輸出存在 log 檔，這個指令可以把 log 叫出來\ndocker container inspect {CONTAINER ID} 完整的輸出容器的設定，如系統路徑、執行命令、網路設定等等\ndocker container stats {CONTAINER ID} 即時顯示容器正在使用多少資源，如 CPU、記憶體、網路流量等\n我不確定怎麼退出，但狂按 ctl+C 就好像蠻有用的 (?)\n刪除容器 1 docker container rm --force ${docker container ls --all --quiet} 這個指令會強制刪除所有容器，包含正在運行與已經停止的。刪除 container 可以透過指令，也可以直接把 docker desktop 退出，就自動會把在 run 的 container 刪掉，但不會刪除映像檔，所以下次回來還是可以再執行，不需要再次下載。\n--all 包含已經停止的 --quiet 只顯示容器 ID ${} 將內層指令的輸出作為外層指令的參數，像是算數裡小括號的概念 --force 強制刪除，不管容器有沒有在執行 所以大括號裡會輸出一堆 ID，然後外部指令就會將這些容器一一刪除！！因為 rm 這個指令通常蠻危險的，因此有比較安全的版本 docker container prune 只刪除已經停止的容器。\nDocker Engine Docker engine 是 Docker 的核心引擎 (daemon)，他負責實際的執行容器、管理映像檔、運行背景程式，並透過 API 進行互動。\n最一開始下載的 Docker Desktop 是桌機的應用程式，包含一些圖形化介面，當然他內建了 docker engine 還有 docker cli。其他的 GUI 還有像是 docker UCP 以及 Portainer。\n前面提到的 Docker hub 則跟本地 docker 沒有直接的關係，但是可以透過 CLI → API 在這邊分享或下載映像檔。\nLab 蠻神奇的，docker 可以在 run 的時候在裡面換檔案，我猜應該還是有 build，但因為檔案很小，看不出來這個時間差是不是。\n主要想考的是書上沒提到的指令，可以透過 --help 去看細節，可以得知從本機複製檔案到容器的語法是 docker container cp \u0026lt;本機路徑\u0026gt; \u0026lt;容器ID\u0026gt;:\u0026lt;容器內路徑\u0026gt;，反之亦然。舉例來說，把資料複製到地端目前位置\n1 docker container cp fe8:/usr/local/apache2/htdocs/index.html . 也可以複製整個資料夾，如\n1 docker container cp fe8:/usr/local/apache2/htdocs/ ./htdocs/ ","date":"2025-09-29T15:36:15+02:00","permalink":"https://miyaya.github.io/p/docker-101/","title":"Docker 101"},{"content":"身為一個工程師，總覺得必須得時時更新自己的硬實力，沒寫點程式就覺得好像腦袋要長蜘蛛網了。 也不排除是工作上的程式偏不好玩。 總之，最近又開始刷題了。\n不過比起以前還要一個個留言點開看解析，身在 AI 時代感覺刷題上有很明顯的差異!! 當然不是叫 AI 直接幫我做，而是我在 Claude 建立了一個 project，然後指定他為一個程式批改者，提供我以下的需求\n指出目前程式的錯誤 說明主要想考什麼 提供 golang 最佳解 (因為我這次想練 go) 解釋以上程式碼的時間跟空間複雜度 提供 C++ 的解法 (因為我以往都寫 C++，感覺要面試也是 cpp 最普遍) 其他類似的題目 甚至我 project instruction 也都是用生成的!\n有一些以前始終想不通的盲點，最近一問之下醍醐灌頂。以前會覺得不斷刷題極其痛苦，對於普通人腦袋的我來說，刷題似乎只是在反覆驗證我很笨 இдஇ\n現在有了個人家教的體驗，可以打破砂鍋問到底，刷題的體驗直接昇華成學習。但我依然覺得刷題是一條漫漫長路，這次沒有特別在找工作，先把筆記寫起來，未來有需要的話可以參考。\n邊界定義遞迴範圍 二分搜尋不外乎最重要的是 boundary 設定，到底是 [left, right] 還是 [left, right) 首先要先確認。\n接著影響到迴圈或是遞迴的參數更新，這邊我都以迴圈為例，因為遞迴還會需要 extra stack memory。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // [left, right) left, right := 0, len(nums) for left \u0026lt; right { // mid = left + (right-left)/2 // 更新：left = mid+1 或 right = mid } // [left, right] left, right := 0, len(nums)-1 for left \u0026lt;= right { // mid = left + (right-left)/2 // 更新：left = mid+1 或 right = mid-1 } [left, right] 閉區間 → 使用 left \u0026lt;= right\n使用閉區間時 left 和 right 都是有效的搜尋位置，當 left == right 時，還有一個位置沒檢查，所以條件必須是 left \u0026lt;= right。\n1 2 3 4 5 6 7 8 9 10 11 初始狀態：[1, 2, 3] ↑ ↑ left right 第一輪：mid = 2, 假設情境太小了，我們要取右半邊 left = mid + 1 = 3 現在狀態：[_, _, 3] ↑ left right 每次的檢查都是排除 mid（新的值為 mid - 1 或 mid + 1）當 left == right == 3，位置 3 還沒有檢查過！如果用 left \u0026lt; right，迴圈就結束了；如果用 left \u0026lt;= right，還會進行一次檢查 ✅\n反之，在 [left, right) 的情況下，更新時右邊界不排除 mid，左邊界要排除，會變成mid + 1。\n1 2 3 4 5 6 7 8 9 10 11 12 left, right := 1, n for left \u0026lt; right { mid := left + (right-left)/2 switch guess(mid) { case 0: return mid case -1: right = mid // 不排除 mid case 1: left = mid + 1 // 排除 mid } } 錯誤範例 閉區用 \u0026lt; 1 2 3 4 5 // [left, right] left, right := 1, n for left \u0026lt; right { // ❌ 會漏掉最後一個位置 // ... } 半開區用 \u0026lt;= 1 2 3 4 5 // [left, right) left, right := 1, n for left \u0026lt;= right { // ❌ 會檢查無效位置 n // ... } 邊界條件不對 在需要排除 mid 的時候卻沒有排除，可能會造成無限迴圈 小結 1 2 3 4 5 6 7 8 9 10 選擇邊界定義 ├── 閉區間 [left, right] │ ├── 初始化: left=1, right=n │ ├── 條件: left \u0026lt;= right │ └── 更新: right=mid-1, left=mid+1 │ └── 半開區間 [left, right) ├── 初始化: left=1, right=n ├── 條件: left \u0026lt; right └── 更新: right=mid, left=mid+1 最後的 return value 關鍵觀察：\nleft 指向第一個不滿足條件的位置 right 指向最後一個滿足條件的位置 以 69. Sqrt(x) 這題來說，假設 x 設定為 8，應該要回傳 2。我們來走一次演算法:\n1 2 3 4 5 6 7 8 9 10 11 初始狀態：left=1, right=4 (假設 right=x/2=4) 目標：找到最大的 k，使得 k² ≤ 8 第一輪：mid=2, 2²=4, 4 \u0026lt; 8 ✓ 答案可能是 2 或更大 → left = mid + 1 = 3 第二輪：left=3, right=4, mid=3, 3²=9, 9 \u0026gt; 8 ✗ 答案不可能是 3 或更大 → right = mid - 1 = 2 第三輪：left=3, right=2, left \u0026gt; right 迴圈結束 我們重新來審視一下終止條件：當 left \u0026gt; right 時迴圈結束，也就是說此時 right + 1 = left。\n在 [1, right] 範圍內，所有 k 滿足 k² ≤ x，在 [left, ∞) 範圍內，所有 k 滿足 k² \u0026gt; x。\n此時如果回傳 left 的話，由於 left 總是指向第一個不滿足條件的位置，即第一個使得 k² \u0026gt; x 的數字，這不是我們要的答案!\n小結 尋找 最後一個滿足條件的位置 → return right\n尋找 第一個滿足條件的位置 → return left\n","date":"2025-09-27T20:22:27+02:00","permalink":"https://miyaya.github.io/p/%E5%B1%85%E7%84%B6%E5%8F%88%E9%96%8B%E5%A7%8B%E5%88%B7-leetcode-binary-search/","title":"居然又開始刷 LeetCode - Binary search"},{"content":"暑假到了，巴黎雖然也難逃熱浪的影響，但空蕩蕩的城市總讓人特別珍惜。\n最近無意間翻到自己年初寫的文章，覺得有些當時寫下所想要發展的專案，日前稍稍改變了一些。因此想藉著這個機會來更新一下近況，以及最近的想法。\n關於減肥 減肥這事，不說還好，一但立下了「我要減肥」的心願，往往是越減越肥。比起年初，我好像體重上沒有變化，但實際上所經歷的是一度 +2 公斤，好不容易才降到年初的體重，而年初的體重離理想還差了 5 公斤⋯⋯不知道回台灣前有沒有辦法瘦一點下來，畢竟每次回去，就算我已經對身材很佛系，還是難逃被唸、跟別人比較的心態。我媽甚至覺得我變胖是因為我生病了？？想知道我到底是有多胖才可以有這種結論 😀😀 ？\n但是我最近看了阿斷的日更 100 天減肥影片，甚至還有粉絲把每天阿斷吃的食譜整理成試算表。看了真的是非常勵志！害得我也去找 Claude 生成 60 天的減肥計劃 XD (因為我太了解自己三天捕魚兩天曬網的個性，100 天一定是沒耐心的，要是真的能撐 60 天就阿密陀佛了) 但至今都還沒有展開，希望這個月有勇氣開始⋯⋯並持續到回台灣。\n羽球 去年因為看了奧運羽球賽，非常熱血！！跟 Romain 心血來潮買了羽球配備、租了場地，結果一整年下來應該去不到 10 次。雖然以我們的惰性，這樣的結果並不意外，但對於生活平常感到疲憊或是生病的次數真的是意外的高，總覺得在運動這方面有時候有點心有餘而力不足，只好再多看幾次阿斷減肥影片來勵志自己(?)\n人生計劃 買房 去年一個衝動看的房子、一個衝動就買了。今年開始跑貸款、做客變、跟建設公司吵架、跟貸款銀行吵架。\n生小孩 前陣子我們去探望朋友與他一歲多的寶寶，我們上次看到寶寶的時候，她才幾個月大，除了吃跟睡之外什麼都不會。這次已經會哇哇作響 (?)、會走、會跑、會爆衝，但因為寶寶的個性很好，我整個愛她愛到不行，雖然她很重但還是會很想抱她、跟她玩，或是看她玩 / 被她玩；反觀 Romain 就不是這樣，他總是在一旁神情緊張兮兮的樣子，彷彿花了很大的力氣把崩潰與尷尬壓在內心深處——欸不是，這位先生什麼都沒做，甚至還跟寶寶保持一個安全距離，彷彿在觀賞某種異於人類的生物。\n我看他對小孩是完全沒輒，而且光是作為一個旁觀者就足以使他感到疲憊不堪 (???) 我真的快笑死。他對小孩排斥的個性大概會是一個我們人生中決定（不會）生小孩很大的變數。雖然我一邊覺得有點可惜，好像人生會少一種體驗，但另一邊又覺得我可以因此去擁有更多時間嘗試與體驗那些我至今仍未、但還很想做的事。\n我們對此仍持保留態度，哪天誰改變心意我們也有彈性，不過目前這樣我們都覺得很好。\n動畫 雖然最近沈浸在 vibe coding 的喜悅中，但前陣子有好好的把時間投資在動畫上。感謝木木動畫課的《獎學金計劃》，讓我為了 1000 塊非常努力的每天做作業。我還應用了在愛紗實用日文課裡頭的《Notion 40天學習計劃》，幫自己排定約25天的計劃：每日完成一點點課程或是一點點作業進度，成效可以說是非常ㄉ好！因為每天的量不會太大，整體的進度也不至於拖到一個月以上，期間剛好也沒有什麼假期或出去玩，在非常專心的情況下完課了。我還摸了一點別的課的學習內容，Zack的角色課、曾右任的 3D 風格課⋯⋯。來放一下我這半年來的練習，希望下半年還有機會可以再做角色跟動畫。\n更好的工作 vs 夠好的工作 最後想用工作來作為結尾，因為我每個禮拜至少都會花個一兩天吵著不想工作，早上起床時尤其顯著。在此我先把工作與上班畫上等號，因為我（還）沒有辦法不上班只工作就有收入。\n更好的工作 直至今日，我還是時不時會打開 chatGPT，詢問我的未來運勢——看我有沒有辦法去規模更大的公司、有沒有機會自己出來接案、能不能去做動畫做遊戲、或是更多的職涯可能性。 我發現我總是想探索更多，我到現在做過無數個實習與 junior 職位，但我還想繼續探索，好像我對現況永遠沒辦法滿意，我還是很好奇「如果換成做ＯＯ感覺也很好玩」。\n夠好的工作 總覺得自己還年輕，因此想多探索，說是這樣說沒錯，但我彷彿忽略了我或許已經花了足夠的時間在探索。\n有天在我大談我如何想當 DevOps 但 chatGPT 說我不適合時，Romain 終於受不了我對未來的想像三天一小改、五天一大換的態度，問我難道不喜歡現在的崗位與工作內容嗎？直說若我喜歡，應該要想辦法發展出更專業、資深的能力，換取更好的機會（薪水、職位、甚至跳槽）。 剛好最近時逢 it 鐵人賽，我每年都想參賽 (甚至還想望得獎出書的那種)(做美夢的部分可能真的是第一名)，但沒有一次成功 XD 今年突發奇想——要學的東西這麼多，不如不要再寫新東西，也不要寫程式，以「觀念」為主，幫自己主題式的學習、釐清概念與用法。多虧了 LLM 的蓬勃發展，省下了很多查資料跟閱讀文獻的功夫，還免去了可能最終還是看不懂的困境。\n不過會不會寫完，還是得到實際寫了、報名了、發文了才知道。這麼多年來，我越來越了解自己的部分就是實際做了才算數，想想的部分也只能算想想而已。\n許多懸念 目前很多事都在進行中，希望到年底就可以水落石出，看到些許進步與成果。\n最後，入職一來想寫的東西終於快寫完了 (再次多虧 AI 的幫助，真的是邊寫邊學，感恩 AI 讚嘆 AI)，入職時給自己許下了要努力升遷的想望，等把這個 repo 提交出去，不知道有沒有辦法因此而加薪。\n","date":"2025-08-18T23:44:41+02:00","image":"https://miyaya.github.io/p/%E5%B9%B4%E4%B8%AD%E5%9B%9E%E9%A1%A7%E9%97%9C%E6%96%BC%E8%BF%91%E6%9C%9F%E7%94%9F%E6%B4%BB%E7%9A%84%E5%90%84%E7%A8%AE%E9%9B%9C%E6%83%B3/1_hu_e7d8447c3d2f745.jpg","permalink":"https://miyaya.github.io/p/%E5%B9%B4%E4%B8%AD%E5%9B%9E%E9%A1%A7%E9%97%9C%E6%96%BC%E8%BF%91%E6%9C%9F%E7%94%9F%E6%B4%BB%E7%9A%84%E5%90%84%E7%A8%AE%E9%9B%9C%E6%83%B3/","title":"年中回顧——關於近期生活的各種雜想"},{"content":"契機 一直有想要學第三外語的想法，之前嘗試在 Duolingo 學一些韓文跟日文，都很有趣，因為都是在台灣容易接觸到的語言，有種「阿～原來是這個意思」，但沒有很有系統性地學習，很容易就斷掉、然後把學到的內容都忘記 XD\n這次剛好我媽買了愛紗的線上日文課，想要系統性的把日文學起來，他們很貼心的提供了40天的讀書計畫，希望可以在今年去日本玩前上完課。\n人稱代名詞 第一人稱 我 片仮名 羅馬拼音 漢字書寫 一般用法 わたし watashi 私 正式用法 わたくし watakushi 私 雖然兩者的漢字寫法相同，但發音不一樣。\n那閱讀的時候要念什麼？ 日文好難 @@\n以下提供一些簡單的例句，不然好像不知道如何應用\n私（わたし） は 学生（がくせい） ではありません。（我不是學生）\n私（わたし） は ソフトウェアエンジニア です。（我是軟體工程師）\n私（わたし） の 名前（なまえ） は 田中（たなか） です。(我的名字是田中。)\n私（わたし） は 日本語（にほんご） を 勉強（べんきょう） しています。(我正在學習日語。)\n私（わたし） は 昨日（きのう） 映画（えいが） を 見（み） ました。(我昨天看了電影。)\n私（わたし） の 趣味（しゅみ） は 読書（どくしょ） です。(我的興趣是閱讀。)\n\u0026ndash;\n我們 片仮名 羅馬拼音 漢字書寫 一般用法 わたしたち watashitachi 私たち 正式用法 わたくしたち watakushitachi 私たち 感覺就是加個 たち 就變複數了。\n比法文簡單多了，謝謝。\n私（わたし） たちは 駅（えき） で 待（ま） ちます。(我們在車站等。)\n私（わたし） たちは 明日（あした） 出発（しゅっぱつ） します。(我們明天出發。)\n私（わたし） たちは 一緒（いっしょ） に 食事（しょくじ） をしましょう。(我們一起吃飯吧。)\n私（わたし） たちは 週末（しゅうまつ） に 買（か） い 物（もの） に 行（い） きます。(我們週末去購物。)\n第二人稱 你 片仮名 羅馬拼音 漢字書寫 限定用法 あなた anata あなた 一般用法 稱呼 + さん 稱呼 + san 稱呼 + さん 尊敬用法 稱呼 + さま 稱呼 + sama 稱呼 + 様 你們 片仮名 羅馬拼音 漢字書寫 一般用法 あなたたち anatatachi あなたたち あなた あなた 在平常會避免使用，因為在許多情境下可能被視為不禮貌或生硬，僅留給夫妻互稱。所以如果問別人叫什麼名字的時候說\nあなた の お 名前（なまえ） は 何（なん） ですか 聽起來就很外國人 XDD 所以，簡潔、日本的用法會是\nお 名前（なまえ） は 這類的句子中可以發現，日本人通常會完全省略主語，因為日語允許省略明顯的主語。 總結來說，あなた 主要使用於\n問路或向陌生人詢問時 外語教材中（特別是會話練習） 某些歌曲或文學作品中 有時在生氣或批評對方時（帶有距離感） 在一般交談中，尤其是對上級或年長者，盡量避免使用 あなた 會更加得體。\nあなたはどこから 来（き） ましたか？(你從哪裡來？) あなたに 会（あ） えて 嬉（うれ） しいです。(很高興見到你。) あなたたち 然後即便要說「你們」，如果用あなたたち也還是太正式了，可能使用的情境有老師對學生說話、面對不認識的一群人時（如問路）、表達不滿或批評一群人時（帶有距離感或責備的語氣），但如果是朋友之間說 あなたたち 就會覺得好像很生疏、陌生。\n所以朋友之間會先叫名字再在後面加 たち，像是\n愛紗（あいさ） さんたち （愛紗和她的同伴們、愛紗他們） 或是使用對方的團體名稱（如営業部の皆さん，營業部的各位）、也可以使用皆さん(みなさん) 是大家、各位的意思。\nは的發音 然後我發現，這邊的は都是發wa的音，查了一下發現是は只有在當助詞的時候才會念wa，在句子裡的意思是把前面詞當作主題，像是\n1 2 3 4 5 私は watashiwa こんにちは konnichiwa 原來日文也有破音字，以前覺得中文跟法文到底在搞什麼鬼，看來自然語言都有這種原罪 (?)\n敬稱 さん跟さま本身既不是第二人稱、也不是第三人稱，是加在人名後面用以表示尊敬或討論他人的用途。\nさん 稱呼 + さん せんださん 千田小姐/先生 たながさん 田中小姐/先生 不管年紀大小，只要是尊稱都可以加さん在名字後面。\nさま　様 稱呼 + さん お父さま お父様 父親 おかあさま お母様 母親 センださま 千田様 千田小姐/先生 さま（様） 是非常尊敬的意思，可以用在不熟、很尊敬的長輩、朋友的父母親，信件收信人的那個「收」。\n第三人稱 片仮名 羅馬拼音 漢字書寫 他 かれ kare 彼 她 かのじょ kanojo 彼女 他們 かれら karera 彼ら 她們 かのじょたち kanojotachi 彼女たち 彼（かれ） は 医者（いしゃ） です。(他是醫生。)\n彼女（かのじょ） はとても 親切（しんせつ） な 人（ひと） です。(她是個很親切的人。)\n彼女（かのじょ） と 映画（えいが） を 見（み） に 行（い） きました。(我和女朋友去看電影了。)\n彼女（かのじょ） たちは 昨日（きのう） パーティーに 来（き） ませんでした。(她們昨天沒有來參加派對。)\n其他非正式用法 片仮名 羅馬拼音 漢字書寫 女生自稱 あたし atashi 小朋友自稱 名字 + ね 名字 + ne 男生自稱 ぼく boku 僕 男生自稱 おれ ore 俺 あたしね、 今（いま） 台湾（たいわん） に 住（す） んでいるの（我現在住在台灣）\nあたしね、 今（いま） パリに 住（す） んでいるの（我現在住在巴黎）\n僕 語氣較溫和、禮貌，適合在較正式或一般場合使用。通常男生用於日常對話，尤其是在不太熟悉或需要表達禮貌的場合。 俺 語氣較隨性、粗獷、男性化，有時帶有自信或霸氣的感覺。適合在非正式、熟悉的朋友或家人之間使用。多為成年男性使用，女性一般不使用（但在某些情況下，像是動漫角色或特定個性的人物，女性也可能使用，表達個性強烈）。\n僕（ぼく）は日本（にほん）に行（い）きたいです。（我想去日本。）\n俺（おれ）はラーメン（らーめん）が好（す）きだ。（我喜歡拉麵。）\n其他第二人稱用法 你 片仮名 羅馬拼音 漢字書寫 歌詞常用 きみ kimi 君 比較高姿態在叫人（粗魯） おまえ omae お前 這個傢伙（很像在指人、不客氣） きさま kisama 貴様 あんた anta あんた ","date":"2025-03-01T13:35:18+01:00","permalink":"https://miyaya.github.io/p/%E6%97%A5%E6%9C%AC%E8%AA%9E%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E4%BA%BA%E7%A8%B1%E7%A7%81%E3%81%AF%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%82%92%E5%8B%89%E5%BC%B7%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99/","title":"日本語學習筆記 人稱——私は日本語を勉強しています"},{"content":"去年結束的時候，我很用力地回顧了 2024 一整年的人生結算，還是忍不住希望以職涯與成就去定義過去這一年是否豐收。先說結論，每一年都結算得好狼狽，因為這並不是我個性與生活的模樣。總之，今年希望可以更誠實的面對自己，然後真實的去培養那些擱在心裡一直想學的酷東西。看在工作之餘，我看似無聊的生活可以長出哪些 branch。\nSide projects Where is Bijou 開始上班加上寫手帳後很踏實的感受到一天可用的時間其實蠻多的，終於不用上一天的學後還要回家熬夜趕作業。不知不覺中貪心的個性已經為目前的生活增添了很多 side project，像是 where is Bijou 是我一邊學 React 一邊做出來的小專案，花了約三、四天配著 chatGPT 寫出來的，雖然因為是學習型專案所以文章寫得比較亂，但這個起頭讓我覺得寫前端蠻酷的，現在真的每天工作都在碰，算是滿足了當初寫後端時的好奇心。\nDivvywise 年初去完一趟布達佩斯後，又想起每次出去玩都有的煩惱：因為我主要用歐元跟台幣、kiki 用英鎊跟台幣，同時我們的消費是匈牙利福林 (Ft)，整個計算變得很複雜，雖然我們每次都蠻佛系在算的，但我總想說如果可以做一個 app 解決這個問題那該有多好。礙於目前我還不會寫 mobile app，就先用網頁開發，還可以順便練習 UIUX、 vercel 部署，目前的進度很慢，主要的問題之一是頁面實在是太醜了，希望近期可以把這個克服！\nGroup project 雖然我覺得光這兩個聽起來就有點忙了，可是因為我還是很想寫後端、最好可以碰到雲的東西，所以在網路上因緣際會找了一個 side project group 加入，甚至還需要面試，我覺得蠻酷的。雖然他們的點子跟我另一個點子蠻像的，讓我不禁手癢想趕快落實我的點子（算是個 social media platform），不過我實在沒有辦法再撥時間出來給一個專案，可能未來吧\u0026hellip;\n想變得更有趣 之前在 Ubisoft 實習的尾聲，主管寫了一份我的實習報告，我們一致都覺得我在 demo 上不夠有創意、會太容易以工程師的角度去描述「開發了什麼」、「實現了什麼功能」，而不是從使用者出發去看需求、然後延伸去討論、展示 feature 的彈性跟極限。\n我覺得這件事對以前的我來說可能無所謂，因為寫後端或是寫邏輯哪有差，如果團隊都是工程師那也沒關係，但我現在的角色往前走了一些，我也希望自己可以有更好的 capability 去觸及設計一個產品時應該要設想得到內容。希望在 demo 的時候、在開發的時候都再更有人性一點。\n要做到這件事我覺得應該有很多種方法，首先最簡單的應該就是多看、邊看到的時候就思考。我希望未來的我是一個有有趣點子的人。\n首先先讓生活多一點娛樂、多一點樂趣。我想說從我一直以來都喜歡的 3D 和因為實習而開始關心的遊戲開始。\nBlender 要說我買過形形色色的線上課程中，Blender 應該是最大宗沒有之一了。\n從 hahow 跟 YOTTA 上面的小深藍，到 PPA 的木木，到一些獨立開課的創作者，我全都有買 XD 但看完的只有 hahow 的小深藍小火車，而且成品還不盡理想 XDD\n去年 12 月底終於開始因為加入了木木的新課程募資，所以開始看他的舊課程。發現很多細節她都省略沒有解釋，有點開心自己的程式跟數學底子終於累積到了一個地步，我可以開始能自動想像這些功能是如何被完成，以及他們是想要解決哪些問題！然而進展到開始需要加入自己的創意的部分的時候，我就會卡住，因為我會想說要自己動手做做看、設計看看，不想只是跟著課裡的範例，但有點茫然（不知從何做起）就會無法往前推進度。現在轉換到 Zack 的課，希望可以換個情境，看能不能透過把底子打好來建立更多靈感與想法。\n最終希望做一些有趣的東西，然後結合 three.js。\n遊戲們 source: polygon review Dave the Diver\n去年從台灣回巴黎的時候，我在機場買了一張 Dave the diver 的遊戲片。我觀望這個遊戲很久了，一玩驚為天人，簡直了！！！有搜集卡牌遊戲的樂趣，但也有主線的任務感、畫面很漂亮，常常有有趣的小支線，整體難易度適中、想放鬆玩經營餐廳的線也沒有問題！於是我天天玩、日夜玩，週末玩、熬夜玩。\n超級好玩，救命。\n夏天我玩了紙片瑪利歐 RPG，我很喜歡，然後聖誕節後得到一張 outer wilds 的遊戲片，希望哪天準備好了可以來玩。玩遊戲是我去實習之後意外喜歡上事情，可以偶爾玩遊戲、沈迷於遊戲，我覺得真的是一件蠻幸福的事情。\n書 去年看了 14 本書，我對看書其實沒有什麼目標，就是快樂就好，阿買了的書要記得看，就這樣而已，去年買了太多書，今年再來慢慢看完。\n書名 評分 小記 最有生產力的一年 5 ⭐️ 12 週做完一年工作 5 聽完有聲書後買了翻譯版，真的很有效地幫自己目標建立 sprint，雖然我個人的完成度總是不太好，不過作為一個生產力系統，這已經是對我最有效的了 最高學以致用法 3 偏無聊 世界太無聊，我們需要文藝復興 4 蠻有趣的書，從聊八卦的角度認識藝術史很快樂 剛剛離開的世界 3 發現我的多重職涯組合 4 閒人出租 4 蠻有趣的題材，可能不算小說，是在講作者把自己租出去的故事 溫泉鄉青春曲 5 三蒲紫苑的新作，反常地講職人跟夢想的相反——一個沒有夢想的學生的生活故事，溫馨可愛的小品，只能說三蒲的書真的品質保證 🔖 詭畫連篇 5 帶插畫的懸疑鬼故事，看了膽戰心驚，故事簡單但我很喜歡講故事的敘事角度，會越看越快因為想知道後面發生了什麼 恆毅力 5 ⭐️ 1 天 1 行小日記，寫出超強行動力 5 透過簡單的方式更有意識的回顧生活，雖然很容易完成但成效出奇的好！ 夠好的工作 5 適合開始在上班時間思考人生的人，像我 世界盡頭的溫室 4 金葉草的長篇小說，但我好像比較喜歡他的極短篇 ⭐️ 高成效習慣 5 系統性的定義「高成效」是什麼，並根據具體的指標去優化，照著思考跟執行感覺真的可以達到長期的成功與幸福 ⭐️ = 推薦的非小說；🔖 = 推薦的小說，真的很好看\n一年過後再來回顧看過的書，有些書已經忘記裡面在寫什麼了。看來適度的寫 review 好像是必要的。\nApps One year 這是這篇文章的封面，也是今年新推出的 app，作者 Alec 和 Sam 認為我們現在的生活太快速，想要推出一款 widget 來提醒一年中還剩下幾天。非常可愛的手繪 ui，程式方面感覺並不多，作者也有提到寫得不多、大部分都是 prompt 出來的。這種可愛、獨特的 app 實在太深我心\u0026hellip;\nRize 總結以上，我在正職之外還有生活、又貪心的想要完成很多事。因此，生產力與時間安排便成了一個真正需要討論的議題。說我是幸運吧，在聖誕節期間，因為看到 M4 加教育價太香了忍不住購入，順手看了很多好用的 app 推薦，我在此時載了 Rize，簡直驚為天人，雖然經考量我一天大概只會用 2-3 小時，所以試用完後就沒有再用付費版，但功能跟介面真的都是一流的體驗，如果我個人使用時間拉長那就會考慮訂閱，在此推推！\n總結 2025 依舊是個貪心的一年，但第一個月的進度還不錯——雖然慢，但有在前進，而且終於體驗到了在職人生，每天都千方百計設想如何過好玩的生活，然後最好能早點退休。\n","date":"2025-02-05T22:45:37+01:00","image":"https://miyaya.github.io/p/2025%E5%B9%B4%E7%9A%84%E6%96%B0%E5%B9%B4%E6%96%B0%E5%B8%8C%E6%9C%9B%E8%88%872024%E6%9C%89%E8%B6%A3%E7%9A%84%E6%9D%B1%E8%A5%BF/1_hu_deaa756f40f18564.jpg","permalink":"https://miyaya.github.io/p/2025%E5%B9%B4%E7%9A%84%E6%96%B0%E5%B9%B4%E6%96%B0%E5%B8%8C%E6%9C%9B%E8%88%872024%E6%9C%89%E8%B6%A3%E7%9A%84%E6%9D%B1%E8%A5%BF/","title":"2025年的新年新希望與2024有趣的東西"},{"content":"為了找工作，我開始自學練習寫 React，多虧了現今有 ChatGPT，可以很快的針對簡單的任務開發甚至是 debug。一邊寫、我也一邊看相關的教學，因此想統整這當中學到的內容寫成文章，專案最終的 live demo 在這邊，不過目前只有很陽春的基本遊玩功能，希望可以找到時間把剩下的內容開發完成。\n初始設定 如題所說，今天要來做一個踩地雷的 clone，想了很久 React 的第一份 project 應該要做什麼好，因為想要做可以互動的東西，結果想到我小時候很喜歡玩的遊戲…我真的很喜歡玩踩地雷，初級我曾經用 6 秒破關（到目前還是沾沾自喜的程度）。\n廢話不多說，因為這篇文章主要想著墨在 React 的部分，所以專案設定我就簡單帶過～\n1 2 3 4 5 6 npm create vite@latest minesweeper --template react cd minesweeper npm install npm install -D tailwindcss postcss autoprefixer npx tailwindcss init -p 使用 node 跟 npm 開啟一個 vite 新專案後，加上 tailwind CSS 作為其中一個 dependency，節省一些設計樣式的時間。\n1 2 3 4 5 6 7 8 9 10 // tailwind.config.js module.exports = { content: [ \u0026#34;./src/**/*.{js,jsx,ts,tsx}\u0026#34;, ], theme: { extend: {}, }, plugins: [], } 1 2 3 4 /** src/index.css **/ @tailwind base; @tailwind components; @tailwind utilities; 專案架構 Component 整個網頁的架構可以用幾個 component 來說明邏輯跟資料流:\nGame - 創建遊戲、紀錄遊戲的邏輯、規則、輸贏 Board - 遊戲盤的實體，裝有許多個 cell Cell - 每一個格子，紀錄了附近有幾個炸彈、被翻開了沒 （因為是第一次開發，所以沒有想得很清楚，請見諒）\nComponent 主要的想法就是把相同概念、領域、規範的程式碼寫在一起，與 class 的概念有點類似，透過寫出一個可以重複使用程式碼的方法，使得整體的程式好讀易懂。\n初步開發 先把剛剛提到的架構元件寫出來\nCell 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // src/components/Cell.jsx import React from \u0026#39;react\u0026#39;; const Cell = ({ value, onClick, onContextMenu, row, col }) =\u0026gt; { return ( \u0026lt;div className=\u0026#34;w-8 h-8 border flex items-center justify-center cursor-pointer\u0026#34; onClick={() =\u0026gt; onClick(row, col)} onContextMenu={(e) =\u0026gt; { e.preventDefault(); onContextMenu(row, col); }} \u0026gt; {value} \u0026lt;/div\u0026gt; ); }; export default Cell; Board 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // src/components/Board.jsx import React from \u0026#39;react\u0026#39;; import Cell from \u0026#39;./Cell\u0026#39;; const Board = ({ board, onClick, onContextMenu }) =\u0026gt; { return ( \u0026lt;div className=\u0026#34;grid\u0026#34; style={{ gridTemplateColumns: `repeat(${board[0].length}, 2rem)` }}\u0026gt; {board.map((row, rowIndex) =\u0026gt; row.map((cell, colIndex) =\u0026gt; \u0026lt;Cell key={`${rowIndex}-${colIndex}`} value={cell.revealed ? (cell.value === \u0026#39;M\u0026#39; ? \u0026#39;💣\u0026#39; : cell.value) : (cell.flagged ? \u0026#39;🚩\u0026#39; : \u0026#39;\u0026#39;)} onClick={onClick} onContextMenu={onContextMenu} row={rowIndex} col={colIndex} /\u0026gt; ) )} \u0026lt;/div\u0026gt; ); }; export default Board; Game createBoard 負責在一開始的時候生成棋盤、放置地雷、並且計算鄰居炸彈有幾個。\nhandleCellClick 處理如果點擊每個格子時的狀況，比如點到地雷則結束遊戲，如果不是地雷的話，則 revealCells 會把附近有幾個炸彈顯示出來。\n💡 阿突然想到，我在這邊放的不是地雷，是我家的貓咪——珠寶，所以以下的地雷、炸彈，我都改稱為珠寶 XD\n當使用右鍵點選格子的時候，handleContextMenu 會將這個標示成貓咪或是取消標示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 // src/components/Game.jsx import React, { useState, useEffect } from \u0026#39;react\u0026#39;; import Board from \u0026#39;./Board\u0026#39;; const createBoard = (rows, cols, mines) =\u0026gt; { let board = Array(rows).fill().map(() =\u0026gt; Array(cols).fill({ value: \u0026#39;\u0026#39;, revealed: false, flagged: false })); let minePositions = []; while (minePositions.length \u0026lt; mines) { let row = Math.floor(Math.random() * rows); let col = Math.floor(Math.random() * cols); if (!minePositions.some(pos =\u0026gt; pos[0] === row \u0026amp;\u0026amp; pos[1] === col)) { minePositions.push([row, col]); board[row][col] = { ...board[row][col], value: \u0026#39;M\u0026#39; }; } } for (let row = 0; row \u0026lt; rows; row++) { for (let col = 0; col \u0026lt; cols; col++) { if (board[row][col].value !== \u0026#39;M\u0026#39;) { let minesCount = 0; for (let x = -1; x \u0026lt;= 1; x++) { for (let y = -1; y \u0026lt;= 1; y++) { if (board[row + x] \u0026amp;\u0026amp; board[row + x][col + y] \u0026amp;\u0026amp; board[row + x][col + y].value === \u0026#39;M\u0026#39;) { minesCount++; } } } if (minesCount \u0026gt; 0) board[row][col] = { ...board[row][col], value: minesCount }; } } } return board; }; const Game = () =\u0026gt; { const [board, setBoard] = useState([]); const [gameOver, setGameOver] = useState(false); useEffect(() =\u0026gt; { setBoard(createBoard(10, 10, 10)); }, []); const handleCellClick = (row, col) =\u0026gt; { if (gameOver) return; let newBoard = [...board]; if (newBoard[row][col].value === \u0026#39;M\u0026#39;) { setGameOver(true); alert(\u0026#39;Game Over\u0026#39;); } else { revealCells(newBoard, row, col); } setBoard(newBoard); }; const revealCells = (board, row, col) =\u0026gt; { if (board[row][col].revealed || board[row][col].flagged) return; board[row][col].revealed = true; if (board[row][col].value === \u0026#39;\u0026#39;) { for (let x = -1; x \u0026lt;= 1; x++) { for (let y = -1; y \u0026lt;= 1; y++) { if (board[row + x] \u0026amp;\u0026amp; board[row + x][col + y]) { revealCells(board, row + x, col + y); } } } } }; const handleContextMenu = (row, col) =\u0026gt; { if (gameOver) return; let newBoard = [...board]; newBoard[row][col].flagged = !newBoard[row][col].flagged; setBoard(newBoard); }; return ( \u0026lt;div className=\u0026#34;flex justify-center items-center h-screen\u0026#34;\u0026gt; \u0026lt;Board board={board} onClick={handleCellClick} onContextMenu={handleContextMenu} /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Game; 最後更新到 \u0026lt;App\u0026gt; component 當中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // src/App.jsx import React from \u0026#39;react\u0026#39;; import Game from \u0026#39;./components/Game\u0026#39;; const App = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Game /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; useState 在 \u0026lt;Game\u0026gt; 裡頭，使用gameOver 儲存遊戲是否結束了，這邊使用 useState 來監控特定變數，當這些變數有更動的時候，頁面才會部分重新 render。\nuseState 會以 array 的形式回傳兩個變數，這樣方便我們重新命名，通常第二個變數會等於第一個變數名稱加上 set，如這邊 [gameOver, setGameOver] 。其中 setGameOver 的參數可以帶入一個變數或是一個方法。\nuseState 也可以記錄 array 或是 class，像是board是一個 2D array，也可以透過 useState 監控。\nuseEffect 1 2 3 useEffect(() =\u0026gt; { setBoard(createBoard(10, 10, 10)); }, []); 在這邊使用 useEffect，使得第一次的 render 會 call createBoard() 這個方法。\n在 React 中，副作用邏輯（side effects logic）是指任何不直接影響 UI render，但與外部環境或系統交互的操作。例如，call API、訂閱或事件監聽、計時器操作（如設置 setTimeout 或 setInterval） 、local storage 或 session 的操作。這些操作通常需要與應用外部的資源或狀態進行交互，因此稱為「副作用」。使用 useEffect 來執行 side effects logic，可以讓 React 在 component 的生命週期中正確處理這些邏輯，如在 mount、update、或 unmount。\nuseEffect 的第二個參數是一個 array，列舉了依賴哪些項目，也就是說當這個 array 裡的東西有了變動，useEffect 內的邏輯就會被呼叫。總共有三種情況:\narray 為空 [] - 只有在第一次 render 的時候會呼叫 array 有塞值進去 - 內容改變時會呼叫 不傳 array 進去 - 每次 render 的時候都會呼叫（這個情形的話形同虛設、沒有提升效率） 功能——產生不同的棋盤大小 架構寫好了之後，來增加實際玩的機制 首先，我們想根據不同的難度，來產生不同大小的棋盤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // src/components/Board.jsx import React, { useMemo } from \u0026#39;react\u0026#39;; import Cell from \u0026#39;./Cell\u0026#39;; const generateTable = () =\u0026gt; { return Array.from({ length: rows }).map(() =\u0026gt; Array.from({ length: cols }).map(() =\u0026gt; Math.floor(Math.random() * 10)) // Random number between 0 and 9 ); }; const Board = ({ difficulty }) =\u0026gt; { const { rows, cols } = useMemo(() =\u0026gt; { switch (difficulty) { case \u0026#39;easy\u0026#39;: return { rows: 5, cols: 5 }; case \u0026#39;medium\u0026#39;: return { rows: 10, cols: 10 }; case \u0026#39;hard\u0026#39;: return { rows: 15, cols: 15 }; default: return { rows: 10, cols: 10 }; } }, [difficulty]); const table = useMemo(generateTable, [rows, cols]); return ( \u0026lt;\u0026gt; {table.map((row, rowIndex) =\u0026gt; ( \u0026lt;div key={rowIndex} className=\u0026#34;flex flex-row justify-center\u0026#34;\u0026gt; {row.map((cell, colIndex) =\u0026gt; ( \u0026lt;Cell key={colIndex} neighborMine={cell} /\u0026gt; ))} \u0026lt;/div\u0026gt; ))} \u0026lt;/\u0026gt; ); } export default Board; useMemo 當遇到複雜的計算時，為了避免重複計算，useMemo 將計算的結果記起來。像是這邊把rows跟 cols 記起來，然後當每次 difficulty 有更動的時候，則會重新運算、並將結果存起來。接著 table 也是一樣使用 useMemo 每次 [rows, cols] 有產生變化時，就會把新生成的棋盤存起來。\n因為這樣， \u0026lt;Game\u0026gt; 和 \u0026lt;Cell\u0026gt; 都可以簡化了！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // src/components/Game.jsx import React, { useState } from \u0026#39;react\u0026#39;; import Board from \u0026#39;./Board\u0026#39;; export const Game = () =\u0026gt; { const [difficulty, setDifficulty] = useState(\u0026#39;medium\u0026#39;); return ( \u0026lt;div className=\u0026#34;container my-10 mx-auto py-8 max-w-4xl border border-pink-400\u0026#34;\u0026gt; \u0026lt;label className=\u0026#34;flex flex-row justify-center\u0026#34;\u0026gt; Difficulty: \u0026lt;select name=\u0026#34;difficulty\u0026#34; value={difficulty} onChange={e =\u0026gt; setDifficulty(e.target.value)}\u0026gt; \u0026lt;option value=\u0026#34;easy\u0026#34;\u0026gt;Easy\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;medium\u0026#34;\u0026gt;Medium\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;hard\u0026#34;\u0026gt;Hard\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;Board difficulty={difficulty} /\u0026gt; \u0026lt;/div\u0026gt; ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // src/components/Cell.jsx import React from \u0026#39;react\u0026#39;; export const Cell = ({ neighborMine }) =\u0026gt; { return ( \u0026lt;button className=\u0026#34;cell bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-0 px-1 border border-blue-200 hover:border-transparent\u0026#34;\u0026gt; {neighborMine} \u0026lt;/button\u0026gt; ); } export default Cell; 功能——連帶打開沒有珠寶的格子的鄰居 當我點某個格子，其中的值是 0 的時候，代表這一個不是炸… 貓咪、鄰居也都不是貓咪，所以理當應該把鄰居們也都遞迴打開。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 // src/component/Board.jsx import React, { useState, useMemo, useCallback } from \u0026#39;react\u0026#39;; import Cell from \u0026#39;./Cell\u0026#39;; const Board = ({ difficulty }) =\u0026gt; { const { rows, cols, mines } = useMemo(() =\u0026gt; { switch (difficulty) { case \u0026#39;easy\u0026#39;: return { rows: 5, cols: 5, mines: 5 }; case \u0026#39;medium\u0026#39;: return { rows: 10, cols: 10, mines: 20 }; case \u0026#39;hard\u0026#39;: return { rows: 15, cols: 15, mines: 45 }; default: return { rows: 10, cols: 10, mines: 20 }; } }, [difficulty]); const generateTable = (mines) =\u0026gt; { const table = Array.from({ length: rows }, () =\u0026gt; Array.from({ length: cols }, () =\u0026gt; 0) ); let placedMines = 0; while (placedMines \u0026lt; mines) { const row = Math.floor(Math.random() * rows); const col = Math.floor(Math.random() * cols); if (table[row][col] !== -1) { table[row][col] = -1; placedMines++; } } return table; }; const table = useMemo(() =\u0026gt; generateTable(mines), [rows, cols, mines]); const [statuses, setStatuses] = useState( Array.from({ length: rows }, () =\u0026gt; Array.from({ length: cols }, () =\u0026gt; \u0026#39;unknown\u0026#39;)) ); const revealCells = useCallback((row, col, newStatuses, table) =\u0026gt; { if (row \u0026lt; 0 || row \u0026gt;= rows || col \u0026lt; 0 || col \u0026gt;= cols || newStatuses[row][col] === \u0026#39;revealed\u0026#39;) { return; } newStatuses[row][col] = \u0026#39;revealed\u0026#39;; if (table[row][col] === 0) { revealCells(row - 1, col - 1, newStatuses, table); revealCells(row - 1, col, newStatuses, table); revealCells(row - 1, col + 1, newStatuses, table); revealCells(row, col - 1, newStatuses, table); revealCells(row, col + 1, newStatuses, table); revealCells(row + 1, col - 1, newStatuses, table); revealCells(row + 1, col, newStatuses, table); revealCells(row + 1, col + 1, newStatuses, table); } }, [rows, cols]); const handleCellClick = useCallback((row, col, clickType) =\u0026gt; { setStatuses(prevStatuses =\u0026gt; { const newStatuses = prevStatuses.map(rowStatus =\u0026gt; [...rowStatus]); if (clickType === \u0026#39;left\u0026#39;) { if (table[row][col] === 0) { revealCells(row, col, newStatuses, table); } else { newStatuses[row][col] = \u0026#39;revealed\u0026#39;; } } else if (clickType === \u0026#39;right\u0026#39;) { newStatuses[row][col] = newStatuses[row][col] === \u0026#39;flagged\u0026#39; ? \u0026#39;unknown\u0026#39; : \u0026#39;flagged\u0026#39;; } return newStatuses; }); }, [revealCells, table]); return ( \u0026lt;\u0026gt; {table.map((row, rowIndex) =\u0026gt; ( \u0026lt;div key={rowIndex} className=\u0026#34;flex flex-row justify-center\u0026#34;\u0026gt; {row.map((cell, colIndex) =\u0026gt; ( \u0026lt;Cell key={colIndex} neighborMine={cell} status={statuses[rowIndex][colIndex]} onClick={(clickType) =\u0026gt; handleCellClick(rowIndex, colIndex, clickType)} /\u0026gt; ))} \u0026lt;/div\u0026gt; ))} \u0026lt;/\u0026gt; ); }; export default Board useCallback useCallback 的主要目的是避免在 component 內部宣告的 function，因為隨著每次 render 不斷重新被宣告跟建立，每次拿到的都是不同的 instance。這樣的 function 如果被當成 prop 往下傳給其他 component，就可能導致下面的 component 無意義地被重新 render。\n但是除非你的 component 有實作比對 prop 做選擇性 render 的檢查，不然就算傳了 useCallback 記下來的 function 進去也毫無意義——他的 render function 還不是會被跑一次。考慮到這一點的話：大部分情況下，我們都不需要用到 useCallback。\n如果你的 function 因為需要用到 props 或 state 而必須在 component scope 裡面宣告、但又同時會被超過一個 useEffect 使用時，就建議以 useCallback 包起來。（解釋得非常清楚，原文在此）\n我觀察的情況是， handleCellClick 的確有符合使用一些 states，所以必須包在 component 裡頭，接著在棋盤上會不斷的被 call，因此看起來這是一個合理的 practice！不過 handleCellClick 裡頭又藏了一個 useCallback function revealCells ，看起來實在有點複雜。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // src/components/Cell.jsx import React from \u0026#39;react\u0026#39;; export const Cell = ({ neighborMine, status, onClick }) =\u0026gt; { const handleClick = (e) =\u0026gt; { e.preventDefault(); // Prevent context menu on right-click if (e.nativeEvent.button === 0) { onClick(\u0026#39;left\u0026#39;); // Handle left click } else if (e.nativeEvent.button === 2) { onClick(\u0026#39;right\u0026#39;); // Handle right click } }; return ( \u0026lt;\u0026gt; {status === \u0026#39;unknown\u0026#39; ? ( \u0026lt;div className=\u0026#34;cell hover:bg-blue-500 hover:text-blue-500 bg-blue-100 text-blue-100 py-0 px-2 border border-blue-400 font-mono cursor-pointer\u0026#34; onContextMenu={handleClick} onClick={handleClick} \u0026gt; \u0026#39; \u0026lt;/div\u0026gt; ) : status === \u0026#39;flagged\u0026#39; ? ( \u0026lt;div className=\u0026#34;cell bg-yellow-500 text-white py-0 px-2 border border-yellow-400 font-mono cursor-pointer\u0026#34; onContextMenu={handleClick} onClick={handleClick} \u0026gt; F \u0026lt;/div\u0026gt; ) : ( \u0026lt;button className=\u0026#34;cell bg-transparent text-blue-700 font-semibold py-0 px-2 border border-blue-400 font-mono\u0026#34;\u0026gt; {neighborMine} \u0026lt;/button\u0026gt; )} \u0026lt;/\u0026gt; ); }; export default Cell; 然後到了這邊，遊戲的狀態有 unknown 、 flagged 、 unreveal ，會呈現相對應的格子。\nUI——新增剩餘的珠寶 套用一樣的概念，我們用變數 remainingMines 搭配 useState 來監控剩下的珠寶。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // src/components/Game.jsx import React, { useState } from \u0026#39;react\u0026#39;; import Board from \u0026#39;./Board\u0026#39;; export const Game = () =\u0026gt; { const [difficulty, setDifficulty] = useState(\u0026#39;medium\u0026#39;); const [remainingMines, setRemainingMines] = useState(20); // Initial value for medium difficulty const handleDifficultyChange = (e) =\u0026gt; { const newDifficulty = e.target.value; setDifficulty(newDifficulty); switch (newDifficulty) { case \u0026#39;easy\u0026#39;: setRemainingMines(5); break; case \u0026#39;medium\u0026#39;: setRemainingMines(20); break; case \u0026#39;hard\u0026#39;: setRemainingMines(45); break; default: setRemainingMines(20); } }; return ( \u0026lt;\u0026gt; \u0026lt;div className=\u0026#34;container my-10 mx-auto py-8 max-w-4xl border border-pink-400\u0026#34;\u0026gt; \u0026lt;label className=\u0026#34;flex flex-row justify-center\u0026#34;\u0026gt; Difficulty: \u0026lt;select name=\u0026#34;difficulty\u0026#34; value={difficulty} onChange={handleDifficultyChange}\u0026gt; \u0026lt;option value=\u0026#34;easy\u0026#34;\u0026gt;Easy\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;medium\u0026#34;\u0026gt;Medium\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;hard\u0026#34;\u0026gt;Hard\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;div className=\u0026#34;flex flex-row justify-center\u0026#34;\u0026gt; \u0026lt;span\u0026gt;Mines left: {remainingMines}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;Board difficulty={difficulty} setRemainingMines={setRemainingMines} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 // src/component/Board.jsx import React, { useState, useMemo, useCallback, useEffect } from \u0026#39;react\u0026#39;; import Cell from \u0026#39;./Cell\u0026#39;; const Board = ({ difficulty, setRemainingMines }) =\u0026gt; { const { rows, cols, mines } = useMemo(() =\u0026gt; { switch (difficulty) { case \u0026#39;easy\u0026#39;: return { rows: 5, cols: 5, mines: 5 }; case \u0026#39;medium\u0026#39;: return { rows: 10, cols: 10, mines: 20 }; case \u0026#39;hard\u0026#39;: return { rows: 15, cols: 15, mines: 45 }; default: return { rows: 10, cols: 10, mines: 20 }; } }, [difficulty]); const generateTable = (mines) =\u0026gt; { const table = Array.from({ length: rows }, () =\u0026gt; Array.from({ length: cols }, () =\u0026gt; 0) ); const statuses = Array.from({ length: rows }, () =\u0026gt; Array.from({ length: cols }, () =\u0026gt; \u0026#39;unknown\u0026#39;) ); let placedMines = 0; while (placedMines \u0026lt; mines) { const row = Math.floor(Math.random() * rows); const col = Math.floor(Math.random() * cols); if (table[row][col] !== -1) { table[row][col] = -1; placedMines++; } } return { table, statuses }; }; const { table, initialStatuses } = useMemo(() =\u0026gt; generateTable(mines), [rows, cols, mines]); const [statuses, setStatuses] = useState(initialStatuses); useEffect(() =\u0026gt; { setStatuses(Array.from({ length: rows }, () =\u0026gt; Array.from({ length: cols }, () =\u0026gt; \u0026#39;unknown\u0026#39;))); }, [difficulty, rows, cols]); const revealCells = useCallback((row, col, newStatuses, table) =\u0026gt; { const stack = [[row, col]]; while (stack.length) { const [r, c] = stack.pop(); if (r \u0026lt; 0 || r \u0026gt;= rows || c \u0026lt; 0 || c \u0026gt;= cols || newStatuses[r][c] === \u0026#39;revealed\u0026#39;) { continue; } newStatuses[r][c] = \u0026#39;revealed\u0026#39;; if (table[r][c] === 0) { stack.push([r - 1, c - 1]); stack.push([r - 1, c]); stack.push([r - 1, c + 1]); stack.push([r, c - 1]); stack.push([r, c + 1]); stack.push([r + 1, c - 1]); stack.push([r + 1, c]); stack.push([r + 1, c + 1]); } } }, [rows, cols]); const handleCellClick = useCallback((row, col, clickType) =\u0026gt; { setStatuses(prevStatuses =\u0026gt; { const newStatuses = prevStatuses.map(rowStatus =\u0026gt; [...rowStatus]); if (clickType === \u0026#39;left\u0026#39;) { if (table[row][col] === 0) { revealCells(row, col, newStatuses, table); } else { newStatuses[row][col] = \u0026#39;revealed\u0026#39;; } } else if (clickType === \u0026#39;right\u0026#39;) { if (newStatuses[row][col] === \u0026#39;flagged\u0026#39;) { newStatuses[row][col] = \u0026#39;unknown\u0026#39;; setRemainingMines(prev =\u0026gt; prev + 1); } else { newStatuses[row][col] = \u0026#39;flagged\u0026#39;; setRemainingMines(prev =\u0026gt; prev - 1); } } return newStatuses; }); }, [revealCells, table, setRemainingMines]); return ( \u0026lt;\u0026gt; {table.map((row, rowIndex) =\u0026gt; ( \u0026lt;div key={rowIndex} className=\u0026#34;flex flex-row justify-center\u0026#34;\u0026gt; {row.map((cell, colIndex) =\u0026gt; ( \u0026lt;Cell key={colIndex} neighborMine={cell} status={statuses[rowIndex][colIndex]} onClick={(clickType) =\u0026gt; handleCellClick(rowIndex, colIndex, clickType)} /\u0026gt; ))} \u0026lt;/div\u0026gt; ))} \u0026lt;/\u0026gt; ); }; export default Board; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // src/component.jsx import React from \u0026#39;react\u0026#39;; const Cell = ({ neighborMine, status, onClick }) =\u0026gt; { const handleClick = (e) =\u0026gt; { e.preventDefault(); if (e.type === \u0026#39;click\u0026#39; \u0026amp;\u0026amp; e.button === 0) { onClick(\u0026#39;left\u0026#39;); } else if (e.type === \u0026#39;contextmenu\u0026#39; \u0026amp;\u0026amp; e.button === 2) { onClick(\u0026#39;right\u0026#39;); } }; return ( \u0026lt;\u0026gt; {status === \u0026#39;revealed\u0026#39; ? ( \u0026lt;button className=\u0026#34;cell bg-transparent text-blue-700 font-semibold py-0 px-2 border border-blue-400 font-mono\u0026#34; onClick={handleClick} onContextMenu={handleClick} \u0026gt; {neighborMine === 0 ? \u0026lt;\u0026gt;\u0026amp;nbsp;\u0026lt;/\u0026gt; : neighborMine} \u0026lt;/button\u0026gt; ) : ( \u0026lt;div className=\u0026#34;cell hover:bg-blue-500 hover:text-blue-500 bg-blue-100 text-blue-100 py-0 px-2 border border-blue-400 font-mono\u0026#34; onClick={handleClick} onContextMenu={handleClick} \u0026gt; \u0026amp;nbsp; \u0026lt;/div\u0026gt; )} \u0026lt;/\u0026gt; ); }; export default Cell; Debug 在來回修改程式的過程中，我常常得到一個 warning\nfix warning: Warning: Cannot update a component (Game) while rendering a different component (Board).\n我研究了一下，發現這是因為在嘗試 render child component 的時候試著更新 parent component，所以可以透過\n將 state update logic 移動到 parent component 更新 child component ，並確保 child component 只透過 callback 來跟 parent component 溝通，而不是直接更新 來解決，也就是 useEffect、useCallback 等 hook 發揮用處的時候到了！\nUI——新增遊戲結局 玩到結束，終究是要顯示輸贏！這邊我想使用一個彈跳視窗，所以需要新增一個 Modal component\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // src/components/Modal.jsx import React from \u0026#39;react\u0026#39;; const Modal = ({ message, onClose }) =\u0026gt; { return ( \u0026lt;div className=\u0026#34;fixed inset-0 flex items-center justify-center z-50\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;bg-white p-4 rounded shadow-lg\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;mb-4\u0026#34;\u0026gt;{message}\u0026lt;/div\u0026gt; \u0026lt;button className=\u0026#34;bg-blue-500 text-white px-4 py-2 rounded\u0026#34; onClick={onClose} \u0026gt; Close \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;fixed inset-0 bg-gray-500 opacity-50\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Modal; 同時，我也新增顯示時間正計時、狀態的顯示 (playing、won、lost) 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // src/components/Game.jsx import React, { useState, useEffect, useCallback } from \u0026#39;react\u0026#39;; import Board from \u0026#39;./Board\u0026#39;; import Modal from \u0026#39;./Modal\u0026#39;; export const Game = () =\u0026gt; { const [difficulty, setDifficulty] = useState(\u0026#39;medium\u0026#39;); const [remainingMines, setRemainingMines] = useState(20); const [gameStatus, setGameStatus] = useState(\u0026#39;prepare\u0026#39;); const [startTime, setStartTime] = useState(null); const [elapsedTime, setElapsedTime] = useState(0); const [modalMessage, setModalMessage] = useState(\u0026#39;\u0026#39;); const handleDifficultyChange = (e) =\u0026gt; { const newDifficulty = e.target.value; setDifficulty(newDifficulty); }; const updateGameStatus = useCallback((unrevealedCount) =\u0026gt; { if (unrevealedCount === remainingMines) { setGameStatus(\u0026#39;won\u0026#39;); } }, [remainingMines]); useEffect(() =\u0026gt; { switch (difficulty) { case \u0026#39;easy\u0026#39;: setRemainingMines(5); break; case \u0026#39;medium\u0026#39;: setRemainingMines(20); break; case \u0026#39;hard\u0026#39;: setRemainingMines(45); break; default: setRemainingMines(20); } setGameStatus(\u0026#39;prepare\u0026#39;); setStartTime(null); setElapsedTime(0); }, [difficulty]); useEffect(() =\u0026gt; { let timer; if (gameStatus === \u0026#39;playing\u0026#39;) { timer = setInterval(() =\u0026gt; { setElapsedTime(prevTime =\u0026gt; prevTime + 1); }, 1000); } else { clearInterval(timer); } return () =\u0026gt; clearInterval(timer); }, [gameStatus]); const handleCellClick = useCallback((clickType, neighborMine) =\u0026gt; { if (clickType === \u0026#39;left\u0026#39; \u0026amp;\u0026amp; gameStatus === \u0026#39;prepare\u0026#39;) { setGameStatus(\u0026#39;playing\u0026#39;); setStartTime(Date.now()); } if (clickType === \u0026#39;left\u0026#39; \u0026amp;\u0026amp; neighborMine === \u0026#39;*\u0026#39;) { setGameStatus(\u0026#39;lost\u0026#39;); } }, [gameStatus]); useEffect(() =\u0026gt; { if (gameStatus === \u0026#39;won\u0026#39;) { setModalMessage(\u0026#39;You won :)\u0026#39;); } else if (gameStatus === \u0026#39;lost\u0026#39;) { setModalMessage(\u0026#39;You lost :(\u0026#39;); } }, [gameStatus]); const closeModal = () =\u0026gt; { setModalMessage(\u0026#39;\u0026#39;); }; return ( \u0026lt;div className=\u0026#34;container my-10 mx-auto py-8 max-w-4xl border border-pink-400\u0026#34;\u0026gt; \u0026lt;label className=\u0026#34;flex flex-row justify-center\u0026#34;\u0026gt; Difficulty: \u0026lt;select name=\u0026#34;difficulty\u0026#34; value={difficulty} onChange={handleDifficultyChange}\u0026gt; \u0026lt;option value=\u0026#34;easy\u0026#34;\u0026gt;Easy\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;medium\u0026#34;\u0026gt;Medium\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;hard\u0026#34;\u0026gt;Hard\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;div className=\u0026#34;flex flex-row justify-center\u0026#34;\u0026gt; \u0026lt;span\u0026gt;Mines left: {remainingMines}\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;ml-4\u0026#34;\u0026gt;Status: {gameStatus}\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;ml-4\u0026#34;\u0026gt;Time: {elapsedTime}s\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;Board difficulty={difficulty} setRemainingMines={setRemainingMines} updateGameStatus={updateGameStatus} setGameStatus={setGameStatus} handleCellClick={handleCellClick} /\u0026gt; {modalMessage \u0026amp;\u0026amp; \u0026lt;Modal message={modalMessage} onClose={closeModal} /\u0026gt;} \u0026lt;/div\u0026gt; ); }; 新增了 modalMessage 來儲存要在 Modal 中顯示的訊息。 更新監視 gameStatus 的 useEffect hook，以在遊戲獲勝或失敗時設定 modalMessage 部署 最後還修修改改了許多東西，不過主要與 React 有關的內容已經大致涵蓋了！因此如果想看完整程式碼的話，可以直接參考 source code。\n我用的是 Vercel，一個免費部署、CI/CD 的 server 服務，使用起來非常簡單，因為可以直接從 GitHub 導入專案，以及許多 framework 的編譯模板，像是 vite 就有包含在內，因此只要一開始設定的時候勾選是 vite 就好了。\n結論 最後，如果我的理解有誤、或是想要提供更好的作法，歡迎留言！也可以寫信給我 miya850604[at]gmail.com，謝謝^^\n","date":"2024-09-08T22:56:57+02:00","image":"https://miyaya.github.io/p/react-hook-%E4%BB%8B%E7%B4%B9%E9%80%8F%E9%81%8E%E8%B8%A9%E5%9C%B0%E9%9B%B7%E5%B0%88%E6%A1%88%E5%AD%B8-react/1_hu_7b56b5d4dc7b43c.jpg","permalink":"https://miyaya.github.io/p/react-hook-%E4%BB%8B%E7%B4%B9%E9%80%8F%E9%81%8E%E8%B8%A9%E5%9C%B0%E9%9B%B7%E5%B0%88%E6%A1%88%E5%AD%B8-react/","title":"React Hook 介紹——透過踩地雷專案學 React"},{"content":"在 IP Paris 的研究所生活，有很重要的一環是實習，學分數佔了碩二的整整一半 (30ETC)。當初申請的時候，我看準了不需要寫論文加上會有六個月的實習，算是對學術研究不在行的我非常友善，也希望可以因此讓未來找正職工作時可以更順利。\n我最後拿到的職位叫作 Rendering Programmer Assistant (算圖助理工程師?)，就是跟我本科完全符合，所以真的是非常開心能夠申請上！！因為過程跟準備的時候經歷了很多煎熬的 moment，因此希望寫下這篇文章可以幫助到需要的人 🥹🥹 未來可能也會寫一些申請 IPP 的過程以及在 IPP 的生活。\n如何申請 回歸正題，第一步是怎麼開始呢? 我們其中一所學校 (Télécom Paris) 剛好 Ubisoft 有派 HR 跟校友來進行宣傳、介紹，說明在遊戲公司的生活、生涯，以及今年有開招的職缺是什麼。 跟台灣的公司蠻類似的，雖然說會特別去一些不錯的學校招生，但工程師畢竟還是個講求公平實力的工作，投遞的連結是公開的，所以有興趣的話直接搜尋 #programmingday 加幾個關鍵字，應該都會有結果。\n開放職缺 我猜他們是固定介紹五個職位，分別是\n寫 all generic functionalities 的 (core) programmer 寫 facilities 的 tools programmer 寫 graphics 的 3D programmer 寫遊戲邏輯的 gameplayer programmer 還有寫網路 features 的 online programmer Ubisoft 來學校的時間是 9 月 13，programming day 定在 11 月底，當時的連結我記得已經可以投遞履歷了，最後申請時間好像是 10 月底，因此準備的時間也還算充足。在填寫申請表單的時候，會需要排序三個希望的順位。\n為什麼我說是固定介紹呢？因為後來公司聯繫上我的時候，說我申請的 3D programmer 今年沒有開缺，他們也沒有因此跟我說我可以選我的第二順位 XD 不知道是已經招滿，還是我的程式跟履歷沒有很吸引他們。總之，我當時閃過好多個想法，其中一個是——該不會填順位也有心機吧！！只能說找工作真的有時候也是需要點運氣。\n註: 我後來跟來自同校的實習生聊天，發現他是有進 programming day，然後錄取之後才被告知沒有 3D 的缺。所以我的情況應該就是比較幸運，原本被丟掉的履歷被撿了回來 XD\nProgramming Day 在投遞履歷之後，會有一個考技術的線上測驗連結，依據申請的職缺會有不同的語言測試，如 C++, C# 等，我這兩個都做了。 C++ 的內容蠻經典的，我自己準備的方向是把 LeetCode 75 做完，我覺得他有幾個優點:\n不會太多題，花一個多月就可以練完 覆蓋的內容比經典 DSA 更廣，包含一些冷門的類別 但如果想加強難度中～高的題目，比如說複雜的 DP、一些圖論的演算法，可能就要自己再去加強。我當初還有同時在面試其他公司，75 我覺得是一邊讀書、一邊準備、一邊慢慢開始面試的高 CP 選擇。接下來我有繼續練習 Top Interview 150，不過沒練幾題就拿到 offer 了。\n根據我個人的經驗來說，DP、貪婪、基本的 graph (traversal 之類的) 演算法依然是經典，所以想找工作的人也可以往這個方向努力。\n面試流程 HR 這一關蠻普通的 XD 全部都是很基本的問題，除了人資聽到我是台灣人之後說自己去過九份、很漂亮之外，其他都是照流程走的感覺: 一些行政問題、為什麼選這家公司、有沒有在玩遊戲、最喜歡什麼遊戲等。\n我在網路上也是查到類似的問題，看來確實一般準備就夠了。\n註: 進了公司之後，發現全部的同事真的都超級、非常、無敵熱愛遊戲，無論是開發遊戲或是玩遊戲、甚至關心遊戲界的各種大小新聞。我在這方面常常跟不上大家的話題，因為我連一台 PC 都沒有，我頂多就是偶爾朋友來家裡玩的時候會打馬力歐派對 (當然我面試的時候不是這樣回答的囉，哈) 總之，因此午餐時間的 chitchat 常常有點壓力 T_T\nTech Interview 這關其實是我最抖的一關，面完的當下甚至我已經覺得生無可戀、未來黯淡無光，後來接到人資的電話，她問我面試的過程怎麼樣，我還得勉強塞起一個笑容然後說，「我覺得主管們人都很好，因為我知道我回答的很差，但他們都沒有失去耐心，還給我很多引導」，然後我不禁乾笑了幾聲，因為我回憶起那天的慘況，真的是欲哭無淚，我甚至面試完當天就都已經跟先生、我媽、我朋友說沒救了，然後放寬心的接受失敗，準備要去其他公司。 然後人資居然就說「我們覺得妳的面試很不錯、很有潛力」(?????)，「希望妳可以加入我們」，我聽到的時候在房間裡無聲的跳來跳去，實在是做夢也想不到。\n回到正題，當時面試的有兩個資深算圖工程師，其中一個是把我履歷撿回來的 aka 我開工後的直屬主管。他根據我的履歷問了很多相關的問題:\n第一個問題是我有什麼 rendering 相關的專案、使用的語言是什麼、清不清楚 rendering pipeline 是什麼。 學校主要用 c++ 與 opengl，但我修的課沒有很深，因此都是一些很基本的作業型專案，有一個是要畫影子的，就問了一些如何算影子的演算法，就此我已經回答的很含糊。\n第二個問題是假設現在要畫一面鏡子/湖的倒影，如何畫出反射的效果。如果不使用光追 (ray-tracing)，可以怎麼做？這邊我腦袋一片空白，內心已經在哭泣。\n第三個問題回到我的履歷，其中一個專案是用 marching cube 做 SPH 的模擬，就叫我解釋 marching cube。\n\u0026hellip;\n最後到了提問的環節。我看著自己準備的草稿，寫了一些針對團隊人數的分配、每天工作內容之類的問題，但我內心知道問這些都沒有用，因為我太好高騖遠了，我根本就不會上。灰心喪志到了極點的 me，畏畏縮縮的問了一句「我覺得我剛剛回答的很糟，請問你們有什麼建議我繼續進修的資源呢」，這句話可能有打動主管，他回了一句 good question，然後真的開始翻找有什麼好的學習資源。\n結論: 心態 其實很難說到底是什麼部分讓我有辦法做這份實習，若真要分析，應該就是一些運氣、一些刷題、一些過去積累的經驗、還有不放棄跟不畏懼的心態。面試的過程大概可以感覺得出來順不順利、內容有沒有可能引起自己的興趣。就算沒有成功，也只是一時的，未來仍然有機會，如果繼續往前進，最終是會走到最適合的地方。\n當時申請前很害怕法文不好、程式又不強的我會找不到心儀的實習，還問了很多同學說該怎麼做，但大家都是佛系的說跟著學校的資源找就好 XD 當時心想，學校哪有提供什麼資源！！沒想到參加了一場說明會就開啟了一扇門，因此想推薦給大家，手法依然可以積極：多修相關的課、架一個放作品集的網站、累積一些相關的專案經驗，但心態可以佛系一點。\n如果這篇文章真的有些幫助的話，麻煩留個言讓我知道！謝謝 XD 因為我偶爾才寫比較有用的文章，大部分都是自己的生活，真的有幫到人的話我會努力多寫一些 😂\n一些資源 我在實習開始前，回台灣耍廢了一個月，開工之後滿是後悔，因為能力有點跟不上，因此把當初主管貼給我的資源分享給大家，若對 rendering 有興趣，可以看看。我也一併把我當時的履歷放上來給大家見笑一下。\nCatlike coding: Unity Custom SRP\nRender Hell by Simon\nCV-2023\n","date":"2024-05-09T21:30:36+02:00","permalink":"https://miyaya.github.io/p/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0-ubisoft-%E7%9A%84%E5%AF%A6%E7%BF%92/","title":"我是如何拿到 Ubisoft 的實習"},{"content":"本文章收錄基本+初級的法文動詞變化，包含現在式 (présent)、複合過去式 (passé composé)、未完成式 (imparfait)、未來式 (futur)，以及比較進階的虛擬式 (subjonctif présent) 跟條件式 (conditionnel présent)。\n大致上動詞變化的規則 大部分來說結尾有 r 發音的，要不是 futur、要不就是 conditionnel，因為 conditionnel 也是從 futur 的字首來的。而 imparfait 字首通常都不會是 r 結尾，然後 subjonctif 的字首結尾通常聽起來都很奇怪 😂 比如說很多 ss。\n一些動詞在使用 passé composé 時需要使用助動詞 être 而非 avoir。這些動詞通常是表示移動、轉變和一些反身動詞。\n因為例子也不多，一共 17 個，啊有些還長很像，點三角形展開，可以全部記起來: arriver partir rester entrer rentrer sortir aller venir devenir revenir monter descendre naître mourir tomber retourner passer 規則變化動詞 規則變化的動詞可以分成三類: -er/ -ir / -re。規則本身這邊就不多做討論了。\n動詞變化規則 第一類以 aimer 來當作例子，則變化如下。\nAIMER 喜歡 Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je j\u0026rsquo;aime j\u0026rsquo;ai aimé j\u0026rsquo;aimais j\u0026rsquo;aimerai que j\u0026rsquo;aime j\u0026rsquo;aimerais Tu tu aimes tu as aimé tu aimais tu aimeras que tu aimes tu aimerais Il/Elle il/elle/on aime il/elle/on a aimé il/elle/on aimait il/elle/on aimera qu\u0026rsquo;il/elle/on aime il/elle/on aimerait Nous nous aimons nous avons aimé nous aimions nous aimerons que nous aimions nous aimerions Vous vous aimez vous avez aimé vous aimiez vous aimerez que vous aimiez vous aimeriez Ils/Elles ils/elles aiment ils/elles ont aimé ils/elles aimaient ils/elles aimeront qu\u0026rsquo;ils/elles aiment ils/elles aimeraient 第二類，舉例來說有 choisir。\nCHOISIR 選擇 Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je je choisis j\u0026rsquo;ai choisi je choisissais je choisirai que je choisisse je choisirais Tu tu choisis tu as choisi tu choisissais tu choisiras que tu choisisses tu choisirais Il/Elle il/elle/on choisit il/elle/on a choisi il/elle/on choisissait il/elle/on choisira que il/elle/on choisisse il/elle/on choisirait Nous nous choisissons nous avons choisi nous choisissions nous choisirons que nous choisissions nous choisirions Vous vous choisissez vous avez choisi vous choisissiez vous choisirez que vous choisissiez vous choisiriez Ils/Elles ils/elles choisissent ils/elles ont choisi ils/elles choisissaient ils/elles choisiront qu\u0026rsquo;ils/elles choisissent ils/elles choisiraient 第三類比較少見一點點，但也是很重要，如 descendre。\nDESCENDRE 下降 Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je je descends j\u0026rsquo;ai descendu je descendais je descendrai que je descende je descendrais Tu tu descends tu as descendu tu descendais tu descendras que tu descendes tu descendrais Il/Elle il/elle/on descend il/elle/on a descendu il/elle/on descendait il/elle/on descendra que il/elle/on descende il/elle/on descendrait Nous nous descendons nous avons descendu nous descendions nous descendrons que nous descendions nous descendrions Vous vous descendez vous avez descendu vous descendiez vous descendrez que vous descendiez vous descendriez Ils/Elles ils/elles descendent ils/elles ont descendu ils/elles descendaient ils/elles descendront qu\u0026rsquo;ils/elles descendent ils/elles descendraient 包含的單字 基本:\naimer, écouter, manger, nager(!), regarder choisir, finir, réussir descendre, entendre, perdre, vendre 初級:\naider, ajouter, arriver, changer, demander, donner, enseigner, essaye(!), étudier, fermer, fumer, gagner, goûter, jouer, laver, monter, occuper, oublier, parler, payer, penser, pleurer, porter, raconter, remercier, rester, retourner, réveiller, tomber, travailler, visiter obéir 沒有 這邊給兩個動詞打上了驚嘆號，因為他們在規則中還是帶一點發音上造成的拼寫變化。\nnager 因為 g 碰上 a 會發嘎的音，所以再加上字尾前，要先卡一個 e。比如說 imparfait 第一人稱會是 je nageais。\n同理 placer 也是在 imparfait 的時候把 c 改成 ç 以維持跟 ce 相同的發音。\nessayer 則是有時候是 y 結尾、有時候是 ie 結尾，查了一下發現原來都可以，一個動詞原來還可以享有兩種拼法！！（坐下 s\u0026rsquo;assoir 也是）只能說：法文，I 服ㄌ U⋯⋯\nPrésent Passé composé Imparfait Futur Subjonctif Conditionnel Je essaie/ essaye ai essayé essayais essaierai/ essayerai que j\u0026rsquo;essaie/ essaye essaierais/ essayerais Tu essaies/ essayes as essayé essayais essaieras/ essayeras que tu essaies/ essayes essaierais/ essayerais Il/Elle essaie/ essaye a essayé essayait essaiera/ essayera qu\u0026rsquo;il/elle/on essaie/ essaye essaierait/ essayerait Nous essayons/ essayons avons essayé essayions essaierons/ essayerons que nous essayions essaierions/ essayerions Vous essayez/ essayez avez essayé essayiez essaierez/ essayerez que vous essayiez essaieriez/ essayeriez Ils/Elles essaient/ essayent ont essayé essayaient essaieront/ essayeront qu\u0026rsquo;ils/elles essaient/ essayent essaieraient/ essayeraient 再補充，雖說也有其他 -yer 結尾的單字，但就沒有這種兩種拼法的特權了。如 envoyer, nottoyer，然後他們也屬於不規則變化，跟上面的命運可說是完全不同！\n不規則變化動詞 一定要會的 être, avoir ÊTRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je suis ai été étais serai que je sois serais Tu es as été étais seras que tu sois serais Il/Elle est a été était sera qu\u0026rsquo;il/elle/on soit serait Nous sommes avons été étions serons que nous soyons serions Vous êtes avez été étiez serez que vous soyez seriez Ils/Elles sont ont été étaient seront qu\u0026rsquo;ils/elles soient seraient AVOIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je ai ai eu avais aurai que j\u0026rsquo;aie aurais Tu as as eu avais auras que tu aies aurais Il/Elle a a eu avait aura qu\u0026rsquo;il/elle/on ait aurait Nous avons avons eu avions aurons que nous ayons aurions Vous avez avez eu aviez aurez que vous ayez auriez Ils/Elles ont ont eu avaient auront qu\u0026rsquo;ils/elles aient auraient 這兩個動詞會最常用到，加上 plus-que-parfait 跟 futur antèrieur 也是從這兩個助動詞去變化，所以要好好記！\n原型動詞長相騙人的 aller, faire, venir, prendre (同場加映跟他們有點像的 dire, devenir, apprendre, se souvenir) 這邊收錄一些以為是 -er/ -ir/ -re 結尾的，但法文直接給你一個出奇不意，怎麼會這麼簡單呢。\nALLER Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je vais suis allé(e) allais irai que j\u0026rsquo;aille irais Tu vas es allé(e) allais iras que tu ailles irais Il/Elle va est allé(e) allait ira qu\u0026rsquo;il/elle/on aille irait Nous allons sommes allé(e)s allions irons que nous allions irions Vous allez êtes allé(e)(s) alliez irez que vous alliez iriez Ils/Elles vont sont allé(e)s allaient iront qu\u0026rsquo;ils/elles aillent iraient 這個字的 subjonctif 我總會不小心跟 avoir 的搞混。後來我發現有個常用的句子，我常在影集裡面看到: \u0026ldquo;Il faut que j\u0026rsquo;y aille.\u0026quot;，意指「我要走了」、「我得走了」，有一個實際句子就比較不會弄錯。\nFAIRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je fais ai fait faisais ferai que je fasse ferais Tu fais as fait faisais feras que tu fasses ferais Il/Elle fait a fait faisait fera qu\u0026rsquo;il/elle/on fasse ferait Nous faisons avons fait faisions ferons que nous fassions ferions Vous faites avez fait faisiez ferez que vous fassiez feriez Ils/Elles font ont fait faisaient feront qu\u0026rsquo;ils/elles fassent feraient faire 我覺得也是很常用的字，他就掌握了最一開始提到的大原則: futur 跟 conditionnel 字首是 r 結尾，subjonctif 是 ss。 啊這個字有個地方很怪，就是 vous 的現在式突然來一個 -tes，跟 dire 一樣。\nDIRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je dis ai dit disais dirai que je dise dirais Tu dis as dit disais diras que tu dises dirais Il/Elle dit a dit disait dira qu\u0026rsquo;il/elle/on dise dirait Nous disons avons dit disions dirons que nous disions dirions Vous dites avez dit disiez direz que vous disiez diriez Ils/Elles disent ont dit disaient diront qu\u0026rsquo;ils/elles disent diraient VENIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je viens suis venu(e) venais viendrai que je vienne viendrais Tu viens es venu(e) venais viendras que tu viennes viendrais Il/Elle vient est venu(e) venait viendra qu\u0026rsquo;il/elle/on vienne viendrait Nous venons sommes venu(e)s venions viendrons que nous venions viendrions Vous venez êtes venu(e)(s) veniez viendrez que vous veniez viendriez Ils/Elles viennent sont venu(e)s venaient viendront qu\u0026rsquo;ils/elles viennent viendraient DEVENIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je deviens suis devenu(e) devenais deviendrai que je devienne deviendrais Tu deviens es devenu(e) devenais deviendras que tu deviennes deviendrais Il/Elle devient est devenu(e) devenait deviendra qu\u0026rsquo;il/elle/on devienne deviendrait Nous devenons sommes devenu(e)(s) devenions deviendrons que nous devenions deviendrions Vous devenez êtes devenu(e)(s) deveniez deviendrez que vous deveniez deviendriez Ils/Elles deviennent sont devenu(e)(s) devenaient deviendront qu\u0026rsquo;ils/elles deviennent deviendraient 雖然這是 -ir 結尾的字，但其實是不規則變化。法文真的是很多規則，然後再有很多例外 🙃 我自己在記的時候，覺得這個字跟 prendre、apprendre有異曲同工之妙，ils/ elles 的動詞變化會多加一個 n 因此念法也不一樣，然後也會影響到 subjontif，因為字首是取 ils/ elles 的現在式。\nPRENDRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je prends ai pris prenais prendrai que je prenne prendrais Tu prends as pris prenais prendras que tu prennes prendrais Il/Elle prend a pris prenait prendra qu\u0026rsquo;il/elle/on prenne prendrait Nous prenons avons pris prenions prendrons que nous prenions prendrions Vous prenez avez pris preniez prendrez que vous preniez prendriez Ils/Elles prennent ont pris prenaient prendront qu\u0026rsquo;ils/elles prennent prendraient APPRENDRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je apprends ai appris apprenais apprendrai que j\u0026rsquo;apprenne apprendrais Tu apprends as appris apprenais apprendras que tu apprennes apprendrais Il/Elle apprend a appris apprenait apprendra qu\u0026rsquo;il/elle/on apprenne apprendrait Nous apprenons avons appris apprenions apprendrons que nous apprenions apprendrions Vous apprenez avez appris appreniez apprendrez que vous appreniez apprendriez Ils/Elles apprennent ont appris apprenaient apprendront qu\u0026rsquo;ils/elles apprennent apprendraient 同場加映，venir 家族的字配上反身。\nSE SOUVENIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je me souviens me suis souvenu(e) me souvenais me souviendrai que je me souvienne me souviendrais Tu te souviens te es souvenu(e) te souvenais te souviendras que tu te souviennes te souviendrais Il/Elle se souvient se est souvenu(e) se souvenait se souviendra qu\u0026rsquo;il/elle/on se souvienne se souviendrait Nous nous souvenons nous sommes souvenu(e)s nous souvenions nous souviendrons que nous nous souvenions nous souviendrions Vous vous souvenez vous êtes souvenu(e)(s) vous souveniez vous souviendrez que vous vous souveniez vous souviendriez Ils/Elles se souviennent se sont souvenu(e)s se souvenaient se souviendront qu\u0026rsquo;ils/elles se souviennent se souviendraient 其他也是假裝 -ir 變化的 partir, sortir, dormir, courir, ouvrir, offrir, mourir PARTIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je pars suis parti(e) partais partirai que je parte partirais Tu pars es parti(e) partais partiras que tu partes partirais Il/Elle part est parti(e) partait partira qu\u0026rsquo;il/elle/on parte partirait Nous partons sommes parti(e)s partions partirons que nous partions partirions Vous partez êtes parti(e)(s) partiez partirez que vous partiez partiriez Ils/Elles partent sont parti(e)s partaient partiront qu\u0026rsquo;ils/elles partent partiraient SORTIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je sors suis sorti(e) sortais sortirai que je sorte sortirais Tu sors es sorti(e) sortais sortiras que tu sortes sortirais Il/Elle sort est sorti(e) sortait sortira qu\u0026rsquo;il/elle/on sorte sortirait Nous sortons sommes sorti(e)s sortions sortirons que nous sortions sortirions Vous sortez êtes sorti(e)(s) sortiez sortirez que vous sortiez sortiriez Ils/Elles sortent sont sorti(e)s sortaient sortiront qu\u0026rsquo;ils/elles sortent sortiraient DORMIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je dors ai dormi dormais dormirai que je dorme dormirais Tu dors as dormi dormais dormiras que tu dormes dormirais Il/Elle dort a dormi dormait dormira qu\u0026rsquo;il/elle/on dorme dormirait Nous dormons avons dormi dormions dormirons que nous dormions dormirions Vous dormez avez dormi dormiez dormirez que vous dormiez dormiriez Ils/Elles dorment ont dormi dormaient dormiront qu\u0026rsquo;ils/elles dorment dormiraient courir 要注意的部分是因為 -ir 前還是 r，所以 futur 就有兩個 r，接著影響到 conditionnel 也有兩個 r。\nCOURIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je cours ai couru courais courrai que je coure courrais Tu cours as couru courais courras que tu coures courrais Il/Elle court a couru courait courra qu\u0026rsquo;il/elle/on coure courrait Nous courons avons couru courions courrons que nous courions courrions Vous courez avez couru couriez courrez que vous couriez courriez Ils/Elles courent ont couru couraient courront qu\u0026rsquo;ils/elles courent courraient 這兩個字的 participe passé (p.p.) 是在這個不規則 -ir 系列中唯一相同結尾的，然後現在式變成 -re 結尾，我覺得很容易全部都混在一起 XD 雖然說沒有特別難記，但因為不算很常用到，練習的次數比較少就還是不太熟～\nOUVRIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je ouvre ai ouvert ouvrais ouvrirai que j\u0026rsquo;ouvre ouvrirais Tu ouvres as ouvert ouvrais ouvriras que tu ouvres ouvrirais Il/Elle ouvre a ouvert ouvrait ouvrira qu\u0026rsquo;il/elle/on ouvre ouvrirait Nous ouvrons avons ouvert ouvrions ouvrirons que nous ouvrions ouvririons Vous ouvrez avez ouvert ouvriez ouvrirez que vous ouvriez ouvririez Ils/Elles ouvrent ont ouvert ouvraient ouvriront qu\u0026rsquo;ils/elles ouvrent ouvriraient OFFRIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je offre ai offert offrais offrirai que j\u0026rsquo;offre offrirais Tu offres as offert offrais offriras que tu offres offrirais Il/Elle offre a offert offrait offrira qu\u0026rsquo;il/elle/on offre offrirait Nous offrons avons offert offrions offrirons que nous offrions offririons Vous offrez avez offert offriez offrirez que vous offriez offririez Ils/Elles offrent ont offert offraient offriront qu\u0026rsquo;ils/elles offrent offriraient 最後一個我覺得變化也是怪且難背。他的 futur 也有兩個 r。\nMOURIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je meurs suis mort(e) mourais mourrai que je meure mourrais Tu meurs es mort(e) mourais mourras que tu meures mourrais Il/Elle meurt est mort(e) mourait mourra qu\u0026rsquo;il/elle/on meure mourrait Nous mourons sommes mort(e)s mourions mourrons que nous mourions mourrions Vous mourez êtes mort(e)(s) mouriez mourrez que vous mouriez mourriez Ils/Elles meurent sont mort(e)s mouraient mourront qu\u0026rsquo;ils/elles meurent mourraient 假裝是 -re 的 sourire, écrire, boire, croire, lire SOURIRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je souris ai souri souriais sourirai que je sourie sourirais Tu souris as souri souriais souriras que tu souries sourirais Il/Elle sourit a souri souriait sourira qu\u0026rsquo;il/elle/on sourie sourirait Nous sourions avons souri sourions sourirons que nous sourions souririons Vous souriez avez souri souriez sourirez que vous souriez souririez Ils/Elles sourient ont souri souriaient souriront qu\u0026rsquo;ils/elles sourient souriraient ÉCRIRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je écris ai écrit écrivais écrirai que j\u0026rsquo;écrive écrirais Tu écris as écrit écrivais écriras que tu écrives écrirais Il/Elle écrit a écrit écrivait écrira qu\u0026rsquo;il/elle/on écrive écrirait Nous écrivons avons écrit écrivions écrirons que nous écrivions écririons Vous écrivez avez écrit écriviez écrirez que vous écriviez écririez Ils/Elles écrivent ont écrit écrivaient écriront qu\u0026rsquo;ils/elles écrivent écriraient BOIRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je bois ai bu buvais boirai que je boive boirais Tu bois as bu buvais boiras que tu boives boirais Il/Elle boit a bu buvait boira qu\u0026rsquo;il/elle/on boive boirait Nous buvons avons bu buvions boirons que nous buvions boirions Vous buvez avez bu buviez boirez que vous buviez boiriez Ils/Elles boivent ont bu buvaient boiront qu\u0026rsquo;ils/elles boivent boiraient CROIRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je crois ai cru croyais croirai que je croie croirais Tu crois as cru croyais croiras que tu croies croirais Il/Elle croit a cru croyait croira qu\u0026rsquo;il/elle/on croie croirait Nous croyons avons cru croyions croirons que nous croyions croirions Vous croyez avez cru croyiez croirez que vous croyiez croiriez Ils/Elles croient ont cru croyaient croiront qu\u0026rsquo;ils/elles croient croiraient LIRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je lis ai lu lisais lirai que je lise lirais Tu lis as lu lisais liras que tu lises lirais Il/Elle lit a lu lisait lira qu\u0026rsquo;il/elle/on lise lirait Nous lisons avons lu lisions lirons que nous lisions lirions Vous lisez avez lu lisiez lirez que vous lisiez liriez Ils/Elles lisent ont lu lisaient liront qu\u0026rsquo;ils/elles lisent liraient 因為發音不規則變化的 acheter, lever, élever, espérer, appeler, envoyer, nettoyer 接下來是看似正常的單字，實際上因為發音的關係，在那邊換 accent、加字母，法文真是酷斃了 😭\n只有過去式是一個 l: appeler\nAPPELER Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je appelle ai appelé appelais appellerai que j\u0026rsquo;appelle appellerais Tu appelles as appelé appelais appelleras que tu appelles appellerais Il/Elle appelle a appelé appelait appellera qu\u0026rsquo;il/elle/on appelle appellerait Nous appelons avons appelé appelions appellerons que nous appelions appellerions Vous appelez avez appelé appeliez appellerez que vous appeliez appelleriez Ils/Elles appellent ont appelé appelaient appelleront qu\u0026rsquo;ils/elles appellent appelleraient 只有兩個過去式沒有加 accent grâve: acheter, lever, élever, espérer, promener\nACHETER Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je achète ai acheté achetais achèterai que j\u0026rsquo;achète achèterais Tu achètes as acheté achetais achèteras que tu achètes achèterais Il/Elle achète a acheté achetait achètera qu\u0026rsquo;il/elle/on achète achèterait Nous achetons avons acheté achetions achèterons que nous achetions achèterions Vous achetez avez acheté achetiez achèterez que vous achetiez achèteriez Ils/Elles achètent ont acheté achetaient achèteront qu\u0026rsquo;ils/elles achètent achèteraient LEVER Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je lève ai levé levais lèverai que je lève lèverais Tu lèves as levé levais lèveras que tu lèves lèverais Il/Elle lève a levé levait lèvera qu\u0026rsquo;il/elle/on lève lèverait Nous levons avons levé levions lèverons que nous levions lèverions Vous levez avez levé leviez lèverez que vous leviez lèveriez Ils/Elles lèvent ont levé levaient lèveront qu\u0026rsquo;ils/elles lèvent lèveraient ÉLEVER Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je élève ai élevé élevais élèverai que j\u0026rsquo;élève élèverais Tu élèves as élevé élevais élèveras que tu élèves élèverais Il/Elle élève a élevé élevait élèvera qu\u0026rsquo;il/elle/on élève élèverait Nous élevons avons élevé élevions élèverons que nous élevions élèverions Vous élevez avez élevé éleviez élèverez que vous éleviez élèveriez Ils/Elles élèvent ont élevé élevaient élèveront qu\u0026rsquo;ils/elles élèvent élèveraient ESPÉRER Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je espère ai espéré espérais espérerai que j\u0026rsquo;espère espérerais Tu espères as espéré espérais espéreras que tu espères espérerais Il/Elle espère a espéré espérait espérera qu\u0026rsquo;il/elle/on espère espérerait Nous espérons avons espéré espérions espérerons que nous espérions espérerions Vous espérez avez espéré espériez espérerez que vous espériez espéreriez Ils/Elles espèrent ont espéré espéraient espéreront qu\u0026rsquo;ils/elles espèrent espéreraient PROMENER Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je promène ai promené promenais promènerai que je promène promènerais Tu promènes as promené promenais promèneras que tu promènes promènerais Il/Elle promène a promené promenait promènera qu\u0026rsquo;il/elle/on promène promènerait Nous promenons avons promené promenions promènerons que nous promenions promènerions Vous promenez avez promené promeniez promenerez que vous promeniez promèneriez Ils/Elles promènent ont promené promenaient promèneront qu\u0026rsquo;ils/elles promènent promèneraient 有 -y 結尾就會換來換去: envoyer, nettoyer\nENVOYER Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je envoie ai envoyé envoyais enverrai que j\u0026rsquo;envoie enverrais Tu envoies as envoyé envoyais enverras que tu envoies enverrais Il/Elle envoie a envoyé envoyait enverra qu\u0026rsquo;il/elle/on envoie enverrait Nous envoyons avons envoyé envoyions enverrons que nous envoyions enverrions Vous envoyez avez envoyé envoyiez enverrez que vous envoyiez enverriez Ils/Elles envoient ont envoyé envoyaient enverront qu\u0026rsquo;ils/elles envoient enverraient Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je nettoie ai nettoyé nettoyais nettoierai que je nettoie nettoierais Tu nettoies as nettoyé nettoyais nettoieras que tu nettoies nettoierais Il/Elle nettoie a nettoyé nettoyait nettoiera qu\u0026rsquo;il/elle/on nettoie nettoierait Nous nettoyons avons nettoyé nettoyions nettoierons que nous nettoyions nettoierions Vous nettoyez avez nettoyé nettoyiez nettoierez que vous nettoyiez nettoieriez Ils/Elles nettoient ont nettoyé nettoyaient nettoieront qu\u0026rsquo;ils/elles nettoient nettoieraient 只有第三人稱單數的天氣 pleuvoir \u0026amp; neiger neiger 不算是規則變化動詞，但只是因為他只有第三人稱單數的變形而已，其他人稱不適用。但變形本身基本上是套用規則變化的。\nPLEUVOIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Il/Elle pleut a plu pleuvait pleuvra pleuve pleuvrait 規則變化複雜到我已經不知道怎麼吐槽 vouloir, pouvoir, devoir, savoir, voir, naître, connaître 想要、能夠、需要這三個字我喜歡一起做比較，儘管他們沒有到很相似。\nVOULOIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je veux ai voulu voulais voudrai que je veuille voudrais Tu veux as voulu voulais voudras que tu veuilles voudrais Il/Elle veut a voulu voulait voudra qu\u0026rsquo;il/elle/on veuille voudrait Nous voulons avons voulu voulions voudrons que nous voulions voudrions Vous voulez avez voulu vouliez voudrez que vous vouliez voudriez Ils/Elles veulent ont voulu voulaient voudront qu\u0026rsquo;ils/elles veuillent voudraient POUVOIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je peux ai pu pouvais pourrai que je puisse pourrais Tu peux as pu pouvais pourras que tu puisses pourrais Il/Elle peut a pu pouvait pourra qu\u0026rsquo;il/elle/on puisse pourrait Nous pouvons avons pu pouvions pourrons que nous puissions pourrions Vous pouvez avez pu pouviez pourrez que vous puissiez pourriez Ils/Elles peuvent ont pu pouvaient pourront qu\u0026rsquo;ils/elles puissent pourraient DEVOIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je dois ai dû devais devrai que je doive devrais Tu dois as dû devais devras que tu doives devrais Il/Elle doit a dû devait devra qu\u0026rsquo;il/elle/on doive devrait Nous devons avons dû devions devrons que nous devions devrions Vous devez avez dû deviez devrez que vous deviez devriez Ils/Elles doivent ont dû devaient devront qu\u0026rsquo;ils/elles doivent devraient 同為 -oir 結尾的 savoir 和 voir\nSAVOIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je sais ai su savais saurai que je sache saurais Tu sais as su savais sauras que tu saches saurais Il/Elle sait a su savait saura qu\u0026rsquo;il/elle/on sache saurait Nous savons avons su savions saurons que nous sachions saurions Vous savez avez su saviez saurez que vous sachiez sauriez Ils/Elles savent ont su savaient sauront qu\u0026rsquo;ils/elles sachent sauraient VOIR Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je vois ai vu voyais verrai que je voie verrais Tu vois as vu voyais verras que tu voies verrais Il/Elle voit a vu voyait verra qu\u0026rsquo;il/elle/on voie verrait Nous voyons avons vu voyions verrons que nous voyions verrions Vous voyez avez vu voyiez verrez que vous voyiez verriez Ils/Elles voient ont vu voyaient verront qu\u0026rsquo;ils/elles voient verraient 最後是 -naître 系列，這個詞是 futur 和 conditionnel 有 accent，其他沒有。雖然 naître 有點複雜，但其實只有被動式比較常見，因此我自己只有記 p.p. 而已。\nNAÎTRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je nais suis né(e) naissais naîtrai que je naisse naîtrais Tu nais es né(e) naissais naîtras que tu naisses naîtrais Il/Elle naît est né(e) naissait naîtra qu\u0026rsquo;il/elle/on naisse naîtrait Nous naissons sommes né(e)s naissions naîtrons que nous naissions naîtrions Vous naissez êtes né(e)(s) naissiez naîtrez que vous naissiez naîtriez Ils/Elles naissent sont né(e)s naissaient naîtront qu\u0026rsquo;ils/elles naissent naîtraient CONNAÎTRE Présent Passé composé Imparfait Futur Subjonctif Conditionnel Je connais ai connu connaissais connaîtrai que je connaisse connaîtrais Tu connais as connu connaissais connaîtras que tu connaisses connaîtrais Il/Elle connaît a connu connaissait connaîtra qu\u0026rsquo;il/elle/on connaisse connaîtrait Nous connaissons avons connu connaissions connaîtrons que nous connaissions connaîtrions Vous connaissez avez connu connaissiez connaîtrez que vous connaissiez connaîtriez Ils/Elles connaissent ont connu connaissaient connaîtront qu\u0026rsquo;ils/elles connaissent connaîtraient 總結 未來有機會再發比較中高階的單字，如果以上有打錯、或是有更好的記法跟解釋，歡迎留言！謝謝！\n","date":"2024-01-31T01:12:54+01:00","permalink":"https://miyaya.github.io/p/%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%B4%9A%E6%B3%95%E6%96%87%E5%8B%95%E8%A9%9E%E8%AE%8A%E5%8C%96%E4%B8%80%E8%A6%BD%E8%A1%A8/","title":"基本初級法文動詞變化一覽表"},{"content":"簡介 去年年底開始看這本書，不禁對新的一年充滿了希望。\n在捷克的時候發現，自己有一個問題，就是注意力超級不集中 XD 這剛好也是這本書的一大命題：每次做一件事的時候極度的專注在當下是高生產力、高效率的充分條件。\n📖 如今，最有生產力的人是那些從容行事的人；而要做到從容行事，最好的辦法就是培養、並維持強有力的專注力肌肉。 📖\n往內在探討動機——所謂高生產力的定義 📖 最具生產力的人，工作速度介於和尚和股票交易員之間：速度快到足以完成每件事，同時又慢到足以讓自己辨識最重要的事，然後從容不迫且用心地執行。 📖\n我很喜歡這本書的一個地方是，雖然歸類於生產力工具書，但作者的文筆很不錯，不僅提供實用的方法，還給我一種能見樹又能見林的感覺。一開始的這段話呼應到後面會提到的「如何提高生產力」，以及什麼叫做高生產力。\n找到那些最重要的事 📖 提高生產力的關鍵，在於創造出更多時間，讓你有餘裕進行實際上對自己有意義的事情。 📖 這三項任務占所有工作的20％，卻帶給你至少80％的價值。「價值」這個詞在此非常關鍵：跟一般有意義的任務不同，這些具終極目標的任務不見得給你個人帶來很多價值或意義，但肯定會對你的生產力帶來極大的價值。 📖 對應到許多其他生產力的書籍，似乎可以歸納出高生產力的究極定義： 我們不能創造時間，因此只能盡可能把時間留給那些最重要的事。像是《生時間》所有的例子，都是在幫讀者節省下花在低報酬事務的時間，留給更有價值的事。而這邊的 有價值 不僅僅是那些有辦法量化的結果，像是工作、薪水、專案，能帶來價值的還有人際關係、熱情所在、提升心靈與生理健康⋯⋯。\n所以其實會覺得時間變多了、精力變好了：「不那麼忙」？ 📖 當你持續長時間工作，或是花太多時間忙東忙西，通常這並不表示你有太多工作要做，而只是意味著你並未明智善用精力和專注力。 📖\n大學時期的我，總喜歡追求很多 threads 同時進行的生活，最好一刻不得安寧，然後有種生活很繽紛、充實的感覺。我並沒有要否定過去的自己，畢竟我很珍惜有那段時間的摸索，但好像過了那段歲月後，若還是追求同樣的生活步調，反而會讓很多事情做不好。\n當時能有很多能量去嘗試、去享受、去犯錯、以及去放棄。在體驗過許多不同領域後，找到自己有興趣的範疇、能夠探索更多有趣的 insight，然後專注於此，還能保有體力過著有餘韻的生活節奏。\n📖 只要有機會，最具生產力的人會優先管理好自己的精力和注意力，時間管理則是次要。 📖 生產力並非指做得更多、更快，而是指用心嚴謹地做正確的事情。這就是為什麼騰出更多時間和注意力空間做事情會如此有效，因為這麼做能賦予你更多空間，做好更高回報的任務、避開低回報任務，而且變得更具生產力。 另一方面，如今的現代人大概都有落入社群媒體的陷阱過，不停的 scroll。我們都知道，這些對我們然後最後對導致情緒低落、生產力低落，甚至在兩者交互作用之下，還會產生一個惡化循環 😱 我想這本書之於現代人的用途，至少對我來說，某種程度上第一步就是從這個陷阱中解套。\n📖 良好的生產力技巧大多有個奇怪的特質：當它們讓你每天完成更多事情時，卻往往讓你感到生產力變低。就像從工作中退一步去計畫、用較少的時間做事情，以及脫離網路等技巧，全都能幫助你完成更多的工作，但也會使你的工作不再那麼刺激，因而營造出一種錯覺，讓你以為完成的工作變少了。 📖\n我自己就是瞎忙冠軍 📖 帕金森定律（Parkinson\u0026rsquo;s law）指出：有多少可運用的時間，就會衍生出足夠的工作量來塞滿這些時間。在我的一年計畫裡，我發現這個定律特別適用於低回報的任務。由於你的大腦邊緣系統會抗拒做更具挑戰、最高回報的任務，因此低影響力的工作支援任務，幾乎就成為「工作迷幻藥」或「工作糖果」。當你在處理這些任務時，自然會感覺很有生產力 📖 忙碌若不能讓你完成任何事情，那它跟懶散不做事又有什麼區別？ 生產力與忙碌的程度或有多少效能無關，它只跟你完成多少有關。 單單只是因為你覺得有生產力，並不代表你真的有生產力。反之，儘管你富含生產力，你卻往往不覺得自己有生產力。 雖說大學時期我參加的活動多、還有課業、打工、出去玩什麼之類的，整體而言行程比較多，那時如果我比較難專心、效率比較差，好像還情有可原。也就是說現在，尤其是目前，我半年前辭去了打工後，生活只剩下研究所跟法文課，生活應該要變得比較輕鬆，時間會自然而然被「生」出來，但似乎也沒有 😂😂 甚至我在學期末只有兩門課，生活彷彿依舊還是被課業塞滿了。我做專案的步調變慢、專注度下降，因為我潛意識裡深知：我時間很多。\n我做什麼都慢慢來，因為我不怕我的時間被浪費掉。\n從一開始的真瞎忙，到現在是裝忙 😂 天啊！！能夠在新的一年開始閱讀這本書，也算是某種程度的幸運吧（比較有動力去面對問題，還可以趁機 set new resolutions）\n透過安排任務與行程來達到自由 📖 簡化行事曆得以創造更多空間留給高回報的任務，如此一來，當臨時發生緊急事件需要處理時，你才有更充裕的空間足以反應。 📖\n看了這麼多本提升生產力、工作效率的書後，似乎終於瞭解到所謂 prductive 的本質。以前真的會因為行事曆被塞得滿滿的，到處東奔西跑，或是擁有很長的工時（至少是與薪資不成比例的工時 QQ）就認為自己做了很多事！而因此為自己感到驕傲。現在看來，以前每年都沒有達成的新年願望，就是在所謂「行程很滿」之下的犧牲品。我總會想，我真的沒有時間做這些事。但事實上是，我們應該要評估應該把精力、注意力、時間留給誰？\n（新年新希望：好比說把我買的一堆線上課程看完，從來沒有，每年都在買，但從來沒有看完過！！）\n📖 因為建立一份任務列表，就等於模擬完成實際工作──雖然什麼事都還沒完成，只是紙上談兵而已。 📖\n（是的，今年也再次把這個願望寫下來了，完成度會如何呢\u0026hellip;\u0026hellip;）\n實際的計畫 📖 野心大絕非壞事──你我都該如此，只不過，為了達成目標所採用的方式愈激進，你就愈不可能持續下去。 📖\n同一時間，我也剛重讀完《12週做完一年工作》，藉著新年的時機，幫自己制定了一連串的長短期目標，等晚些時間再來回顧、盤點，看看做得怎麼樣。這本書沒有很實際的說明要怎設置實際的計畫，在這部分比較接近老生常談，就推薦大家去看《12 week year》啦！\n話說，如果從另一個角度，因為《12 week year》是屬於 top-down 的目標設置，搞不好也可以採用像是《原子習慣》這類 bottom-up 的方法，以免目標太過龐大 (which means, you should build a system here)\n自主性 📖 生產力相關書籍之所以能吸引眾多讀者，是因為書中承諾能夠幫助我們重拾對所做一切事情的掌控權。 我喜歡那種「事情都在我掌控之中」的感覺。當我從腦海中清出所有任務、計畫，以及懸而未決的事情後，我獲得更多的注意力，足以專注在眼前的任務上，這讓我對於自己的工作有更大的控制權，並且讓我變得更有生產力。 📖\n我超級喜歡做計畫。\n但此時這也是一個陷阱（對我而言）。\n我容易淪為在做完計畫後就止步於此，沒有真實的行動\u0026hellip;\n承諾與初衷 在自主性與承諾與行動之間，《12週做完一年工作》給了很好的解釋，有絕對的自由與彈性，勢必相對的要持續跟承諾性的對自己問責。\n📖 如果你不重視自己當下努力做出的改變，或是不清楚自己為何想要完成更多的深層原因，你當下就不會有動力做出短暫的犧牲，以達成長期的目標。\n呈前段所說，我自己有一個很不好的習慣：我只喜歡做規劃、不喜歡執行。\n想說這到底什麼鬼 XDD 我豈不成是什麼夢想家，其實根本沒有執行能力嗎!! 從另一個角度來看，我其實超級喜歡拖延，可能在某種程度上，當我做完安排之後我已經滿足了，潛意識沒有繼續堅持的理由（天啊，我的大腦好笨）\n為此，我試過很多方法：看心理諮商、閱讀《拖延心理學》以及各種提升生產力的書、使用數位工具提醒自己、追蹤任務等。但大部分都失敗了，有時候有用、有時候卻會沒有用，這是為什麼呢？我最近找到了真正的原因。\n好了！來做吧！ 📖 生產力的技巧是用來幫助你更聰明地工作；但前提是，你得真正工作，不然再好的技巧也沒用。\n看到這邊，我再次心有戚戚焉，忍不住為自己沒達成的目標找藉口：我真的沒有時間做這些事啊啊啊。\n📖 《戰惰》（The Procrastinator\u0026rsquo;s Handbook）一書作者麗塔．艾米特（Rita Emmett）總結得非常好；在她提出「艾米特定律」（Emmett\u0026rsquo;s law）時是這麼說的：「害怕做某件事所耗費的時間和精力，比真正做那件事本身還要多。」\n事實上，我超級愛拖延，有那麼多無趣的功課、乏味的任務，以及無人問責的項目。我在設置目標上總是充滿動力跟憧憬，但一旦完成之後，我再也不會打開我的記事本、notion 任務資料庫、 todo list 去檢查完成了沒，漸漸的，我的目標變得越來越難以企及。\n📖 這正是為什麼要用心嚴謹工作，而非更快、更辛苦工作的另一項重要原因。藉由放慢工作腳步，你處理事情的思慮也會更加周延、覺知力更強；如此一來，當你眼前出現新的事情，你也更容易看清它能帶給你多大的回報。\n對我而言，真正的問題是我覺得那些任務、那些被我排在行程裡的事都太無聊了。\n📖 每當我嘗試一次只做一件事時，我總覺得自己好像錯過了什麼好玩的事情。\n這應該是我從這本書最重要的 take-away，也是我今年真正的課題——把專注執行變的好玩一些。這也是我從這本書找到，我總是不行動、拖拖拉拉背後的真正原因，這些任務不好玩、乏味，光是想到就提不起勁，怎麼有辦法還勉強自己動身 (真的是藉口一堆)\n📖 唯有當你一次只做一件事時，你才能有足夠的注意力投注其中。 📖 要把你在工作上投注的專注力從原先的53％，提高到80％或90％，並非一朝一夕就能做到，但它能帶給你意想不到的成效，非常值得你付出努力。 📖 「人的思緒總是游移不定。」而研究證實：「游移不定的心思並不快樂。」從進化的角度來看：「具有思索非眼前發生事情的能力，屬於認知的高階功能，但它卻伴隨著情緒的成本。」雖然你的時間極其有限（所以生產力才會如此重要），但也正因如此，你更應該放慢腳步，在提高生產力的同時，全心全意享受這個過程。 因為我深深知道，光靠意志力是沒有用的。對我來說，我的意志力脆弱到連鼓勵自己下床的勇氣(?)都沒有，我平常要是想耍廢，是會躺平直到下午4點才勉強起床，因為實在太想尿尿了。(沒錯好荒謬) 如果想要達成成功的專注、進入心流，那就是讓做這件事情的本身變得有趣，讓我的大腦知道這件事的價值，以及當下是很好玩、很值得付出時間的！畢竟，人類的生理機制沒有那麼完整規劃未來的設計，更何況我注意力能集中的時間太短了。\n📖 一次只做一件事還賦予我更多的注意力空間，讓我更富同情心、更體貼，且更快樂。我強烈相信，一個人在努力提升生產力時，一定要具備豐富的同情心：不僅對別人慈悲，對自己也是一樣。 📖 總之，要做到一次只做一件事需要某些調整，但我相信這麼做不僅可以幫助你完成更多工作，還能幫助你成為更好的人。 這方面，在我看諮商的時候、以及《拖延心理學》中都有提到。我常常為了很多事情而自責，即便我可能沒有意識到我正對自己感到不滿，但從很多情緒用字中，諮商師點出我對自己的苛責，有時候一些無傷大雅的紓壓方式可能真的就是好好放鬆、大吃一頓，這些都是沒關係的。舉例來說，因為我的拖延，導致很多事情沒有在第一時間完成，因此感到沮喪跟無力，更沒有動力去做。但追究起原因，我就真的不想做這些事情，拖延可能是壞習慣、但或許也是難免。我慢慢的在練習對自己說沒關係，知道背後的原因，能夠更理智的去看待事情。看得多、看得遠，自然就培養出了換位思考的能力。\n在《12週做完一年工作》中的盤點章節中在在提到盤點的意義，並不是為了讓我們情緒低落、譴責自己糟糕的成效，而是能夠週期性的客觀評估。首先第一步就是，學會如何心平氣和的接受自己被打一個分數，然後藉此當作未來改正的動力。一開始我覺得很難，畢竟一個 40% 的成效擺在眼前真的不是很好看，但漸漸的練習就會理解到，人生就是這樣，起起伏伏，沒有辦法天天過年嘛！\n📖 要克服負面的自我對話實在很難，但我內心有一部分就是相信：到最後，我肯定會沒事的。\n正念、心流、冥想 最後，這或許是幫助專注力訓練肌肉的最佳運動，因此在許多生產力書籍都會提到的一個項目。\n📖 藉由正念和冥想，你將學會控制自己的專注力，進而投注更多注意力在眼前的任務上。 📖 每天只要五到十分鐘冥想，就足以重新改造你的大腦，因而徹底改變你看待自身工作與生活的方式。雪倫採用的是切合實際的冥想方式，並將之視為從容度日、與自己內在連結，進而活出幸福人生的一種方式 我嘗試過幾次，但一般時候做總好像沒什麼幫助：我對練習呼吸、閉上眼睛專注在自己身上一點興趣也沒有。睡前的正念練習倒是讓我都睡得太快，還做不到一半就睡著了。\n後來我開始做瑜伽，我依舊對練習呼吸沒有太大的興趣，但是每一次的伸展、不同的姿勢，我能因此而更專注在當下、在自己身上。甚至做完之後，我還感到心裡飄飄的，好像放下了什麼重擔，變得輕鬆了一些。\n📖 正念能讓你從容做好眼前的工作，因為它讓你真正退一步思索想要達成的目標、領會你當下的感受，並瞭解你當下在想些什麼。據雪倫表示，這樣的機會每天多到無以計數：「在你談話之前、開會前或處理任何事情之前，不妨退一步，試著與自己的內在連結，看清自己想要什麼。譬如：你最想從談話當中看到什麼結果？然後朝那樣的結果努力，而不是任由你的感覺牽著鼻子走。」正念讓你每天隨時得以設定「微小計畫」，一整天累積下來，終會讓你變得更具生產力。 📖\n不管是提高生產力、調整作息、減肥、運動，所有他人推薦給我們的，最終都是要自己去嘗試才能真正體會到適不適合自己。\n回顧 像是《刻意練習》一再強調的，不斷練習是不是正確的學習之路，而是要有意識的去觀察、調整自己的狀態；還有《子彈思考整理術》中提到的，把你所想要關注的記錄下來，若時時刻刻我們都能活在當下、定時回顧，那我們則永遠不會停下腳步前進。當然別忘了執行計畫或許最有效的《12 week year》。\n📖 這個方法的主要精髓，在於每週回顧一次熱點清單，想想你在過去一週分別花多少時間在上面，並想想未來的一週你打算關注哪些地方。 雖然我花了好幾個星期，才將各個熱點底下的承諾和責任全數列出，然而一旦完成之後，每當我望著這張清單，就能清楚看見我的人生風貌在我面前展開。 📖 最具生產力的人與其他人不同的地方在於：他們每個星期都會修正方向，一步步把事情做得愈來愈好。 實際應用與連結 節錄書中列出的挑戰 📖 你應該在下班前，或是上床前，就先決定隔天要達成的三項目標。 📖\n大部分的挑戰我覺得都很實用，操作起來也很容易，我覺得光是為了這些挑戰，就很值得入手這本書。 所有的挑戰其實也都可以跟其他書籍相關聯：如每日三個重點、保持好精神可以對應到《生時間》、利用黃金時段工作可以對應到《12 year week》、捕捉以及熱點可以對應到《搞定》。\n《生時間》與 Things 3 📖 後來，我想到一個建立計畫總清單的簡單方法，亦即把它們與熱點結合，將所有計畫分門別類歸在各個熱點之下。（如果你一翻開本書就看到這一頁，這幾句話應該會讓你一頭霧水吧！）就像創立一個隨時可供檢視的熱點清單一樣，這張清單簡明易懂，但非常有效。\n看到這邊如果你覺得太抽象，那建議你看《搞定》這本書，裡面歸納任務、分配時間的說明寫得非常好，後來我甚至因為漂亮的介面去買了 things 3，我覺得很好用，真的是幫助大大，自從我習慣把要做的事情打進去之後，就真的再也沒有忘記該做的事。 書中提到的熱點就是 things 3 裡面的「領域」，可以幫助使用者分門別類該做的任務。使用簡單、同步性好、介面漂亮，推推！\n總結 📖 追求生產力的過程，往往也是認清自我極限的過程。 📖 能否每天從容嚴謹且意志堅定地做事，決定生產力的高低。不過，找出背後的深層意義也同等重要。你行動背後的意圖就像是連接箭頭的箭桿，若你不深入探索自己內心深處為何想要完成某一件事，便很難日復一日提升自己的生產力。這個生產力觀點是本書截至目前為止最不迷人的忠告了，但它應該是最重要的。若是你不在乎自己究竟想做出什麼改變，就算你投入無數的時間提高生產力，或是培養新的習慣，都是徒勞；因為你不會有動力長久維持這些改變。 去年在辭職之後，終於把精神跟體力贏了回來。以前我總說「沒有時間」、「沒有力氣」，那些話都是真的。因為打工的體力活實在是太累人了，我已經沒有一絲絲力氣坐在書桌前，學新東西也好、寫日誌也好，任何有真實 input/output 的活動我都沒有辦法做了，我的體力沒有辦法支撐我的注意力跟心思，我只能坐在沙發上、躺在床上享受電視跟社群媒體帶給我的無腦的快樂。\n而如今，我有辦法提筆，邊想望著我的未來，提筆寫下意圖 (intention)、目標、計畫\u0026hellip;\u0026hellip;，然後漸漸地朝著目標前進。\n生活品質與生活本質的核心 📖 我很快就意識到，身邊的人不光是我計畫存在的理由，而且是我計畫存在的目的。是這些人給了我努力的意義，而且我至今所做的每一份工作，這些人也賦予了它們意義。 正因為身邊的人，我們才會做現在做的事情，他們也是推動我們完成更多成就的關鍵。與其他人維持良好的社交關係，已被證實能讓我們更幸福、更投入工作，並且想要提高生產力。 總而言之，人是追求生產力的背後原因。 📖\n我以前從未這麼想過，甚至還會覺得維持好習慣、高生產力，都是一種在競爭環境之下的產物，除了提升競爭力之外沒有其他的好處跟動機。但其實不然，想想也覺得蠻合理的：當一個人的身心靈狀態好，沒有過多的社會壓力，我們自然能選擇理性、善良、寬容。\n📖 因為大腦無法分辨觀想與實際經驗的區別，因此你在回想時，等於讓最有意義的經歷重複發生。日積月累下來，你的大腦便將這些點連接起來，形成一條軌跡，讓你相信自己的人生深具意義。 📖\n這本書的金句書摘實在太多，因為電子書畫線的功能很方便，我就一時畫線一時爽、一直畫線一直爽。真的是一本閱讀時看了會頻頻點頭，之後回想還是會覺得很有收穫，實作上來也很有幫助的一本書！\n","date":"2024-01-26T16:13:16+01:00","permalink":"https://miyaya.github.io/p/%E9%81%A9%E5%90%88%E6%96%B0%E7%9A%84%E4%B8%80%E5%B9%B4%E6%9C%89%E5%80%8B%E5%A5%BD%E5%B8%8C%E6%9C%9B%E6%9C%80%E6%9C%89%E7%94%9F%E7%94%A2%E5%8A%9B%E7%9A%84%E4%B8%80%E5%B9%B4/","title":"適合新的一年有個好希望——《最有生產力的一年》"},{"content":"前言 多虧 2022 暑假時心血來潮買了一台 Kobo，讓我有機會在國外還能享受到中文閱讀的樂趣。而且 9 月開始讀書之後，通勤時間變得很長，因此手上握有一台閱讀器，就可以根據當下的心情選擇想讀的書，而不用侷限於紙材書的體積、重量，讓苦悶的搭車時光美好一點。\n雖然通勤時間一直都還是維持很長很長，但從去年的下半年開始演變成買書的速度遠大於看書 😂，因為一邊讀書加上一邊打工的日子持續太久，生活有些失衡、burned-out，買東西的樂趣 (?) 沒有辦法促成想讀書的動力，實在太疲憊了。買來的書大約有近一半沒有開始閱讀，有些書則是開了後沒有很好看，因此一直被我擱置著XD\n可能一年回顧下來，我會因此立志 2024 會多認真把書閱讀完。\n另一方面，嘗試了有聲書，覺得部分書籍是一個很不錯的體驗，雖然很多人說有聲書很方便，可以在搭車、做家事的時候聽，但因為我不是買小說類型的有聲書，就還是會想要做筆記，這個時候就還是需要拿手機出來紀錄。但小說我又會想要透過閱讀文字來想像跟感受那個氛圍與情境，可能我還沒有習慣有聲書像是背景播放的模式吧！\n電子書大推坑 其實一開始在網路上看到大家推坑電子閱讀器的時候，我只想說那不然就去實體店摸摸看機器好了。結果店員介紹完一輪我有興趣的那台之後，我馬上就買了😂 在買了電子閱讀器之後，我整個就像是暈船的少女，完全無法自拔，覺得他就是我這輩子的真愛了。甚至我之後還到處跟同事朋友說一定要買一台電子閱讀器：「這會是你人生中最棒的投資！！！！」（我的原話沒有這麼直接，但是心裡是這樣吶喊的沒錯）\n封閉式 vs 開放式 電子閱讀器其實很簡單，分成封閉或是開放式，用手機的系統來比喻的話，封閉式有點像 apple，你在 ios 裡載的軟體啊、檔案啊都是只屬於他們自己的，沒有辦法帶到其他平台；反之開放式有點像 android，今天你想用三星、明天你想換 google pixel，啊你買的軟體也不會就不能用了。只需要把各家的軟體下載進電子閱讀器就可以使用！ 封閉式的好處是比較穩定，可能目前也是比較主流一點點。開放式的好處則是可以統整四散各家的書籍，假如你有在不同平台買書的話。\n樂天 Kobo 閱讀器 誠如前段所說，無論是開放還是封閉，其實現在也都有支援 app 內閱讀的功能，那你就可能就會質疑，我用平板看書就好啦！ 確實。\n但閱讀器的好處實在太多了：\n保護你的眼睛，採用的電子墨水技術不像一般螢幕的藍光 可以無痛畫線，畫了再擦掉，還可以輸出註記與筆記 甚至可以查字典，可以看原文書、一邊學語言 有的支援有聲書功能，不過我都用手機 app 連結藍芽耳機，所以好像閱讀器本身有沒有沒差 紀錄閱讀時間，我自己會覺得蠻勵志的 XD 推薦相關書籍，我最喜歡就是想逛就能逛、買了可以馬上看的那種即時滿足感（宅） 完全防水，如果一邊泡澡一邊閱讀\u0026hellip;好爽 只是目前黑白的閱讀器比較多，習慣看漫畫、雜誌的讀者可能就要選購比較大台的閱讀器，或是好啦你就用平板。 我自己用的是 kobo libra 2，上面的功能都有符合，而且我還硬是要用這台看漫畫 😂 如果要懶人包推薦的話，依照習慣可以分成：\n比較常看英文書買 kindle、只看中文書買讀墨、都有的話買 kobo。 喜歡隨身帶的買小尺寸、只放在家裡的買大尺寸，建議買帶按鈕的，筆功能的看口袋深度+個人需求。 完成閱讀總列表 2022 📖 統計數值\n總共 - 5本(不含漫畫)\n語言 - 中文(5/5)\n類別 - 非小說(1/5); 小說(4/5)\n歡迎光臨夢境百貨：您所訂購的夢已銷售一空 婚前一年 姊妹 如果我們無法以光速前進 子彈思考整理術：釐清超載思緒，化想法為行動，專注最重要的事，設計你想要的人生 漫畫的話，當時趁特價買入了一堆進擊的巨人，主要是動畫還沒畫的集數。真的太神、太好看了。雖然許多人對這樣的結局不甚滿意，但我個人覺得很滿意，就算沒有到完美但也不影響他在我心中是神作的地位！今年年底終於動畫版出來了，我坐在螢幕前面大哭特哭哭，感謝 Mappa 把動畫版做出來。氣氛、音樂、口白、畫面堆疊出來的作品，以及這麼多年來的心路歷程，《進擊的巨人》稱之神作當之無愧。同去年所說，還是看動畫好看，至少我是看動畫才懂了艾連的心境，有夠可憐。\n2023 📖 統計數值\n總共 - 19 本\n語言 - 中文 (17/19)、英文 (2/19)\n類別 - 非小說(11/19)、小說(5/19)、圖文書 (3/19)\n媒體 - 電子閱讀器 (16/19)、有聲書 (3/19)\n👑 查令十字路 84 號 不便利的便利店1 \u0026amp; 2 別讓自責成為一種習慣：放過自己的100個正向練習 忘憂音樂盒 只工作、不上班的自主人生：人氣podcast製作人瓦基打造夢幻工作的14個行動計畫 打造第二大腦：多一個數位大腦，資訊超載時代的高效能知識管理術 82 年生的金智英 👑 明日，明日，又明日 刻意練習：原創者全面解析，比天賦更關鍵的學習法 斜槓青年：全球職涯新趨勢，迎接更有價值的多職人生 搞定！工作效率大師教你：事情再多照樣做好的搞定5步驟 [有聲書] Make time [有聲書] 拖延心理學 火箭老媽，烏龜老爸：我家，或許也是你家的故事 愛書小日子 內向小日子 就算長大了，也還是會難過 [有聲書] The 12 Week Year 簡要心得與類別(不含漫畫) 書名 類別與關鍵字 喜歡程度 有的話會想買續集或推薦其他人看 大綱 歡迎光臨夢境百貨：您所訂購的夢已銷售一空 奇幻小說；溫馨、感動 個人覺得偏小品，不是很符合我的口味。看完的時候就覺得「不錯」這樣，但也沒有慾望想再買第二本 🌟🌟🌟 有點猶豫 許多與夢境相關的極短篇，有些人喜歡的理由應該是很溫馨，不過我覺得在夢境外的描述讓我有點出戲，不知道是翻譯不夠好還是我就不喜歡這種說故事方法 婚前一年 推理(?)小說；渣男、感情 到底是不是推理小說不知道，真的要看推理小說我可能還是會選東野圭吾。除此之外描述的故事很在地，而且蠻貼近現實生活，不錯 🌟🌟🌟🌟 尚可 渣男的故事，看到結局會有種登愣的感覺。回去翻很多小細節、甚至還上網爬文，因為看不懂結尾XD 沒有覺得很精彩，但因為整體很寫實，不禁覺得若發生在現實生活應該是蠻精彩的 姊妹 感情小說；節奏慢、悲傷 看完就會覺得：「看完了」的那種喜歡程度，尤其我對探索內心的悲傷、情緒這類文學實在沒什麼興趣。當初買只是因為原作者是法國人，然後封面上寫劇情有大轉折，恩真的嚇我一跳 🌟🌟 還好 一個抑鬱女子的痛苦心路歷程，看完也是登愣的感覺，不過並稱不上是精彩的震撼 如果我們無法以光速前進 科幻小說；溫暖 看完整本會覺得蠻滿意的，獲得了一些能量，也對人性vs科技彷彿有些新的觀點 🌟🌟🌟🌟🌟 滿意 背景可能是未來、外星等科幻的設定，但最終都會把故事拉回人與人之前的互動 子彈思考整理術：釐清超載思緒，化想法為行動，專注最重要的事，設計你想要的人生 個人成長；實用、時間管理 看完很期待馬上實作，不過還是看個人需求，這本書好像沒有打到我當時生活的痛點 🌟🌟🌟🌟🌟 滿意 透過記錄下生活所有代辦事項，觀察過去與現在以便未來更有效率的運用時間 進擊的巨人 漫畫 會想要膜拜作者的喜歡程度；話說，還是動畫看了比較爽 🌟🌟🌟🌟🌟 會很想要跟其他有看的人討論；然後叫沒看的人這輩子一定要看；自己有空的時候會再拿出來看 會有巨人冒出來吃人、讓大家的生活很悲慘的世界設定，因此人類蓋了層層高牆來阻擋巨人，原本以為會是反烏托邦爽片或腦片，結果看了之後成為人生最愛的漫畫之一 書名 類別與關鍵字 喜歡程度 有的話會想買續集或推薦其他人看 大綱 查令十字路 84 號 非小說、書信 沒有看過這種文體（可能有，交換日記？）非常真摯、禮貌的文筆可以一窺當時的時代環境以及兩人簡單卻深刻的跨國友情 🌟🌟🌟🌟🌟 超級好看！不愧為文學經典 美國作家海倫·漢芙與英國古書銷售商法蘭克·鐸爾的往來信件內容 不便利的便利店1 \u0026amp; 2 文學小說；溫馨、感人 第一集比《歡迎光臨夢境百貨》，但沒有《解憂雜貨店》好看。第二集沒有比第一集好看很多，但講述了很多角色後續的人生故事，結局的結法算是讓我蠻滿意的 🌟🌟🌟🌟 不錯的小說 開便利店的廉女士某天錢包被偷了，被一個人很好的流浪漢搶(?)回來，因此她決定讓他來當自己的便利店大夜班…以及身旁的人一連串的故事。 別讓自責成為一種習慣：放過自己的100個正向練習 非小說；心理勵志、大眾心理學 行動導向的心靈書籍，不是俗濫的雞湯、看了不會生氣(?)，反而會反思自己的行為並可以立刻做出簡單的行動改善問題，個人認為很實際 🌟🌟🌟🌟 低潮時候的首選 真的收錄了 100 個思維以及行動上的練習，幫助自己更快樂。每個都小而實際、很好閱讀也很好上手 忘憂音樂盒 文學小說；溫馨、微奇幻、極短篇 又是《解憂雜貨店》風格再現的書，但是不知為何很不有趣，內容連貫性也不高，啊那個音樂盒店是到處快閃嗎？ 🌟🌟 特價99才買的 這家音樂盒店的老闆，擁有一種特殊的能力，他聽得見這些心事重重的人內心重複播放一首歌曲。 只工作、不上班的自主人生 非小說；生涯規劃 有探討如何找喜歡的職涯、如何行動等等，以及一些時間、精力分配的問題。文筆不錯，這本書也可以當作找書的起點，因為作者推薦了許多好書。 🌟🌟🌟🌟🌟 應該會成為生涯規劃的top10之一 瓦基離開原公司創業的心路歷程跟過程。列點說明一路上學習到的東西以及該注意的地方。 打造第二大腦 非小說；商業工具書、成功法、知識管理 透過 CODE 以及 PARA 大法，歸類每天搜集到的知識與參考資料，知識管理系統可以更加整潔，也更容易找到東西，自然提升生產力。 🌟🌟🌟🌟🌟 需要跟著實作才真正有價值。適合「那個東西在哪裡看過但找不到」的人、創作者、或是一般人想你的整理數位系統也蠻實用 筆記方法-CODE法則：獲取、組織、萃取、表達；管理筆記的系統-PARA系統：專案、領域、資源、檔案庫 82 年生的金智英 小說但放了很多真實數據；時代小說、女權、諷刺 看完再次慶幸沒有生在韓國。在某個時代背景下，每個人都是金智英 🌟🌟🌟🌟🌟 做好心理準備的話就可以看，女性悲歌 金智英的一生：新舊時代的南韓在性別議題上的問題 明日，明日，又明日 翻譯文學；愛情、創業、友情、人生 太好看了… 廢寢忘食地看，這就是人生，不完美但你也不能怎麼樣，只好明日明日又明日 🌟🌟🌟🌟🌟 2023必看、2023最好看 山姆與莎蒂，童年時在醫院偶遇，但發生了一些事，彼此的生命反覆交錯又分開。再次相遇後決定一起創業，但世事難料，他們之間的複雜的關係持續推動著彼此的感情與人生。 刻意練習 非小說；正向心理學、潛能開發、人格天賦 撇開最後例子一堆看得很吃力之外，不意外的都還是一些體力型、記憶型的項目，啊我自己是覺得這個理論已經無法支持現在的知識型工作（統整、梳理新知識、或是根據手邊資料思考並輸出等） 🌟🌟 其實整本書就一句話：「有意識的刻意練習才能系統性的達成目標」 我們想要學習新技能不應該依賴天賦，而是靠著一些技巧刻意練習而成功 斜槓青年 非小說；職涯發展 我蠻意外這是一個中國作者寫的書，因為整個書大讚資本主義(?) 看的時候覺得有點好笑。另一方面，後半段感覺有點像集結諸多其他職涯發展的書的讀書心得(?)，但從某個角度來看，是 是看完這本就等於看了很多本(??) 🌟🌟🌟🌟 我個人其實覺得看了蠻勵志的，雖然有些章節好像沒有與主題有直接的關係。適合喜歡看職涯發展類的書的人 我居然忘記這本書在寫什麼，上網一查發現這本書毀譽參半，哇哈哈！大概就是斜槓的定義、如何準備心態、跟如何應映現在的社會趨勢以保有足夠的實力，吧？ 搞定 非小說；時間管理、商業工具書 我覺得非常實用，理論寫的可行、可靠，文字讀起來也很輕鬆但不會太短、太口語。 🌟🌟🌟🌟🌟 很適合很忙碌的現代人，同推應用程式 thing 3 介紹GTD系統：透過「捕捉（記下來）-理清、分類（決定怎麼處置）-回顧（避免瞎忙）-執行」來協助人把所有重要的事情做好，同時減輕頭腦記東西的負荷。 Make time 有聲書；原文書；時間管理、時間規劃、商業工具書 算是我第一本有聲書，因為這本書算是很口語，句子也都不長，算是幸運的選到一本適合輕鬆聽的書，提供的提供的「highlight」方法非常實用。 🌟🌟🌟🌟🌟 也很適合給忙碌的現代人，喜歡《最有生產力的一年》的話應該也會喜歡這本書 介紹 “highlight-laser-energize-reflect” 的系統以及細節，包含一堆給自己省時間、生時間的方法，有的蠻極端的，但秉持著實驗精神，可能有機率值得一試 拖延心理學 有聲書；心理學 適合「知道為什麼就會可以比較理性解決問題」的人，因為解釋得很完整，也提供解法（心境上跟實作上），不算是心靈雞湯，實用！聽完之後覺得應該要買紙本，這樣才比較方便畫線，因為我的筆記上甚至寫了：「蠻實用的可以再聽一次」（請問到底為什麼不直接把聽到什麼寫下來） 🌟🌟🌟🌟 雖然看完的我還是一直在拖延，但這本提供了一個比較理性的觀點。我的 take away 是拖延的時候會盡量不要太譴責自己XDDD （推薦給大家，很實用的） 解析拖延行為背後的心理動機跟過程，也有提到如何克服 火箭老媽，烏龜老爸 圖文書；非小說 我對家庭議題的感動點其實蠻低的，不難看但這本書好像沒有很打動我ㄟ 🌟🌟🌟 適合喜歡李白的人 描述李白跟家人的故事、互動 愛書小日子 圖文書；非小說、極短篇、小品 看了之後我才發現，其實我好像沒有那麼愛書 😂😂 雖然不少點還是心有戚戚焉，但因為現在太少看小說了，就比較難體會一些沈浸在故事情節的部分 🌟🌟🌟🌟 喜歡看書的人，看了就會覺得內心暖暖的很可愛 愛書人的日常，跟內心小劇場 內向小日子 圖文書；非小說、極短篇、小品 喜歡上面的風格的話就也會喜歡這本，因為作者是同一個人，也是一本可愛的圖文書，可以很輕鬆地看完 🌟🌟🌟🌟 內向人共感適用 內向的人超多小劇場一次全部畫出來 就算長大了，也還是會難過 非小說；心靈勵志 當初因為手邊有很多電子書點數要用，加上有點低潮，買了一拖拉庫心靈勵志書，甚至還有好幾本還沒看完 🌟🌟🌟 不難看的心靈雞湯 各種方面給你一些建議，讓你有辦法快樂一點，哪怕這些理論你可能已經知道 The 12 week year 非小說；原文書、有聲書、商業工具書 喔這本也是非常實用，從規劃、實踐到回饋，很像把專案 sprint 的時間尺度拉大，並應用到個人目標的領域上，可想而知應該是一個可靠的系統 🌟🌟🌟🌟🌟 有夢想卻沒有好計畫來實踐的人非常適合 透過 divide-conquer 建立 vision-goal-plan 一致的系統，並教導如何建立系統與背後的心態、以及如何避免常見的陷阱 值得一記的筆記 如果我們無法以光速前進 留在地球上的理由，僅因一個人便足夠了。\n我們透過消費想要獲得的，難道只有情感嗎？人類追求的不是意義嗎？只消費排除了意義的情感，難道不會使人類淪為單純地被物質所束縛的動物嗎？況且人類最初追求意義的行為，\n不也是一種為了抵達高次元的，而非最終的幸福的方法？\n意義賦予在脈絡之中，但有時對一些人而言，需要的並不是有含義的眼淚，而是眼淚本身。\n如果我們因為擁有某種物質而得到情感上的滿足，是不是也可以理解為是想擁有那種感情呢？\n總有一天，我們會以和現在不同的面貌生活在另一個世界，哪怕是在遙遠的未來也還是會有人孤獨和寂寞，並且渴望觸及到什麼。\n不便利的便利店 2 一段好的關係，絕對不會從天而降，而是需要透過思考、判斷與努力才能獲得。\n明日，明日，又明日 同意和另一個人一起玩，風險可不低，因為這代表你願意敞開自己，放下防禦，承擔受傷的可能性。人類這樣做就像狗露出肚皮一樣，表示「我知道就算你有能力傷害我，也不會這麼做」。也像狗用嘴叼住你的手，但絕不會咬下去。一起玩需要信任和愛。 在遊戲裡，次序最為重要。遊戲自有邏輯，但玩家也要在遊玩中摸索出自己的邏輯，才能獲得勝利。任何勝利都有次序。所有遊戲都有最佳解。 因為我自己會寫程式的關係，讀到跟開發有關係的就會不禁思考，這是可行的嗎？或是這是有邏輯的嗎？我不敢說這本書的遊戲都可能真的可以被做出來，但至少描述得煞有其事（我也沒有真的做過遊戲就是），讓我一直很在意的是有一次莎蒂說 render engine 一定要自己刻，我整個嚇壞，不可能吧！！！\n『雙人孤獨』意思是即使跟其他人在一起，也會覺得自己形單影隻。」賽門轉頭看著他老公的眼睛，「在遇到你之前，我一直都有這種感覺。跟家人、朋友、每一任男朋友在一起的時候都是。因為太常有這種感覺，我以為活著就是這樣，活著就得接受人在根本上是孤獨的。」賽門眼睛濕潤，「我知道我很不可理喻，我知道你不在乎德文或婚姻。我能說的只有我愛你，謝謝你還是跟我結婚了。\n好浪漫！！！太浪漫了 😭😭😭\n只要你相信，那麼名字就是命運。 會，在我心裡她會。我太熟悉你媽媽了，我可以扮演她。跟我媽媽和我奶奶也是這樣，還有我小時候最好的朋友有娜，她在她親戚家旁邊的湖裡淹死了。世界上沒有鬼，但是這裡，」她指指自己的頭，「是一座鬼屋。」 「還有什麼比工作更好？」他停頓，「還有什麼比工作更糟？」 明日，明日，又明日， 日復一日碎步前行， 竭至歷史的最後一個音節， 我們的所有昨日為傻瓜照亮 歸向塵土的道路。熄了吧，熄了吧，區區燭火！ 生命只是行走的影子，是可憐的演員， 短暫登台時的喜與悲， 過後就不再有人傾聽。這個故事 由傻瓜講述，充滿喧囂與憤怒， 沒有任何意義。\n這段是經典《馬克白》的其中一段，我自己很喜歡這部莎劇。看到此處真的是內心很激動，豁然理解為什麼書名取為《明日，明日，又明日》，中文譯名也翻得很好。這段話似乎貫穿了整本書想傳達的故事核心概念，有點惆悵人生就是這樣（畢竟是場悲劇），但又因為悲劇本身而感到浪漫。\n「也許是某種比你孩子的意志更強大的力量？甚至比生物學更強大？」 「你說的是哪種力量？」 「演算法。」阿拉巴斯特的眼睛迅速掃視房間，彷彿他們正受到監控，接著壓低聲音說，「你知道吧，看不見的力量，偉大的智者，指引我們所有人的人生。」 「你好迷信。」 她讀過一本談意識的書，書上說人類的大腦在長年運作下，會製造出所愛之人的人工智能。大腦收集數據，在腦海裡建構出那個人的虛擬版本。在那個人死去後，你的大腦仍然相信那個虛擬的人存在，因為的確，腦海裡的人還在。不過，過了一陣子，記憶會漸漸淡化，每一年，這個當時憑藉活人製造出的人工智能都會漸漸消減。 這段完全讓我想到《如果我們無法以光速前進》其中一章（也是我印象最深刻的一章），把死去的親人的抽象性格存在某種圖書館(?)，此虛擬的版本可以提供給親人「再現」的服務，天啊太可怕了，光想到就雞皮疙瘩。\n莎蒂還沒辦法把娜歐米當成完整的人，這又是一件不能輕易承認的事。她認識的許多母親都說孩子從一來到這個世界就有自己的樣子，但莎蒂不同意。沒有語言的人算是什麼人？沒有品味呢？沒有偏好？沒有經驗？走到童年的盡頭時，哪個成年人會認為自己從一開始就是完全體？莎蒂知道就連她自己，直到最近都還不是個完整的人。期許孩子從一開始就一切俱全並不合理。娜歐米現在還只是一幅素描，到了某個時候，就能成為完整的3D角色。\n看完我自己畫線的地方，再次覺得這本書實在太好看了 😍 透過對話與行為的描繪，他們的人生好像在我眼前歷歷在目，他們的人生好像又涵蓋了許多人體驗、未體驗過的人生：所有快樂與不快樂、沈重與難以釋懷的傷痛、友情愛情與家人的關係。\n結語 沒有特別計算閱讀的數量，但數量的確可以反映出行動的樣貌，非常期待可以繼續完成閱讀更多好書！再次感謝閱讀器這個偉大的發明，好處太多了，真的是相見恨晚。\n","date":"2024-01-15T23:15:39+01:00","permalink":"https://miyaya.github.io/p/%E5%85%A9%E5%B9%B4%E5%89%8D%E6%88%91%E8%B2%B7%E4%BA%86%E9%9B%BB%E5%AD%90%E9%96%B1%E8%AE%80%E5%99%A8%E7%84%B6%E5%BE%8C%E5%91%A2/","title":"兩年前，我買了電子閱讀器⋯⋯然後呢"},{"content":"前言 安排了 2024 一開始去一直以來很想去的捷克，終於有機會嚐嚐聽聞許久類似於台灣食物的料理、還有一訪新藝術時期有名的畫家慕夏。因為不想為了多走幾個國家而淪於走馬看花的行程（另一方面，這個時候去匈牙利的機票太貴了），因此把足跡都留在捷克，多安排了一些小鎮的行程，也是很有趣！\n預算 機票 ORY - PRG 來回 169.98€ 折合約 6700 台幣\n飯店（含城市稅） 城市 天數 價錢 € CK 2 111.35 KV 1 99.6 Prague 2 125 Airport 1 96.7 平均 72.1€/ 晚 總共 216.4€/ 人 折合約 7378 台幣\n交通 巴士 22€ (Prague-CK 來回 + Prague-KV 來回)\n輕軌*4 4.93€\n總共約 27€/ 人 折合約 921 台幣\n行程 📝 Day 1: 從巴黎飛到布拉格、再搭巴士到 CK 小鎮 (Český Krumlov 庫倫洛夫)\nDay 2: CK 小鎮\nDay 3: 一早搭巴士回布拉格\nDay 4: 布拉格\nDay 5: 一早搭巴士去溫泉小鎮 (Karlovy vary 卡羅維瓦利)\nDay 6: 中午搭巴士回布拉格、晚上搭公車去機場飯店\nDay 7: 回巴黎\nCK 小鎮說一生必去的城市好像有些言過其實 我們第一天就在 CK 小鎮落腳，也去了大家網路推薦、幾乎一致好評的地窖餐廳 Krčma Šatlava，不小心點了兩人套餐，上菜的時候真的不可思議，因為一份套餐只要 880 CZK ，但目測的份量大概四個人吃都綽綽有餘 … 有一個超大豬膝、豬肋條約 8 根、5 支雞翅?、2 隻大雞腿，還有一些馬鈴書跟蔬菜餅。毫不意外，勤儉持家的我們兩人把剩下的食物連同醬料都打包了。結果是吃到隔天還吃不完 = = 建議有打算要去的，如果不是超級特別愛吃肉，謹慎選擇。\n因為接下來每一天我只要聞到有烤肉味，我整個人渾身不對勁、食慾下降 🤢🤢。捷克傳統料理的肉太多了，我看我還是先 pass 好了。\n隔天我們花了約將近一天的時間在城裡逛逛，這個小鎮真的很小，店家彼此距離約 3 分鐘的腳程就可以走到。遠一點的一些城堡、塔的景點，從市中心出發也是在 15 分鐘內的閒晃就能走到。 可能是天氣因素加上這個城市有點小，整個城市沒有到非常令人驚艷。但登塔、以及在一些高地望出去的風景還是很漂亮，感覺得到老城保護的很好，捷克的老式建築也很有特色：紅瓦屋頂、圓拱形牆壁。\n網路上查到太多資料說「此生必去」、「ＯＯ媒體推薦童話小鎮」，這類標題不禁把期望值拉得很高。也有可能歐洲真的太多所謂「世界最美ＯＯ」，確實 CK 小鎮很漂亮，我也覺得不虛此行，不過歐洲也有其他城市也是相同的特別與美麗。喔對了我真的要吐槽，有人還說什麼 CK 小鎮是布拉格近郊，巴士隨便搭單程兩個半小時起跳，都快到國界了，不要跟我開玩笑好嗎。\n布拉格 第一天在布拉格有先快速吃個小點，找到一間這邊有名的連鎖速食店 Baguette Boulevard ，雖然取了一個很法式的名字 😂 最讓我驚豔的是裡面居然有賣自製的 iced tea，喝起來味道很淡（稱讚意味，歐洲普遍的軟式飲料實在都太甜了）、然後副餐有賣湯。我直接興奮到模糊、大點特點、喝到好感動！！！薯條也不錯吃，醬料給的方式很比利時（大方）。\n後來有好幾天都是吃亞洲食物，因為我對肉肉料理實在沒有辦法。居然在下大雨的寒冷傍晚找到一間小火鍋 Basu 巴蜀 = =，不小心開點後發現是網美餐廳（端來的肉盤還放了乾冰在冒煙），結果開吃之後直接不可思議，太好吃了吧 … 如果說在歐洲好吃的火鍋是海底撈，那這間就是最好吃的小火鍋（不是，我甚至沒有在法國吃過小火鍋誒）而且也沒有到很貴，可以點到的食材品質也都很不錯 … 忍不住再回味一下吃到茼蒿跟娃娃菜的感動瞬間。\n最後一天在城堡區，決定再吃一次當地料理，結果一試，選到一間氣氛很好、服務生態度超級好、食物也不錯吃的 Restaurace U Labuti 。我點了在奧匈捷都還算蠻有名的炸雞排？還是炸豬排？ Schnitzel ，不錯不錯。推薦給怕肉肉全餐但又想體驗當地料理的人 XD\n欸！怎麼都在聊吃的啦！\n因為真的好便宜又好好吃，這一週旅行我還忍不住三進三出 Comebuy ，大吃珍珠，烏龍奶茶有夠好喝。🧋\n慕夏博物館 本趟旅行的重頭戲，其實比想像中還要再小一些。可以看的展品沒有到很多，動線設計也是普通，不過對新藝術有興趣的人我覺得實在不能錯過。看著這些精緻的廣告畫作，不難想像20世紀初世界一片和樂、蓬勃的光景。\n如果有去布拉格的城堡區，千萬不要錯過裡面的教堂，其中一面玻璃畫是由慕夏負責，真的好美。\n溫泉小鎮倒是不要錯過 這個城市的風景，我個人覺得大勝 CK 小鎮。CK 比較像是保存良好的老城區，KV 則像是童話小鎮，每個房子的顏色都很粉嫩，雖然天氣很差，但還是可以看到整個城市的風格非常和諧且舒適。\n這裡也可搜集到所有捷克有名的有機保養類品牌 Botanicus 、 Manufaktura 、 Apoteka ，而且不會發生突然有一團亞洲觀光客如蝗蟲過境的掃盪商店、大聲喧嘩的場景，舒服。\n我們在路邊真的捕捉到許多提供飲用、洗手的自然泉水，也看到很多路人去裝水來喝，而且還一臉津津有味、意猶未盡的樣子，甚至還拿寶特瓶裝一大堆。結論是不好喝、非常不好喝，供參。\n捷克整體印象 街景 很多房子感覺因為觀光的關係，改造成類似博物館的內容，雖然內容很難引起一般人的興趣，但可以想像他們對觀光、文化的重視？\n另一方面，走在路上會遇到不少美術工作室、畫廊，裡面的作品很有他們的特色，也有一般人買得起的作品 XD 整體的體驗很不錯。\n人情 普遍來講，可能很依賴觀光加上捷克語偏小眾，用英文溝通都不是問題，只是有時候有些人臉真的好臭 🙈 原地嚇壞，但各地應該都是有友善的人跟機車的人，還好我線條很粗通常都沒有受到太大的影響。\n第一天晚上我們剛抵達 CK 小鎮，還在車站邊走邊查路，突然一旁路人就跟我們說要往上面走。我們內心滿頭問號，想說他們怎麼知道我們要去哪裡 😂 後來猜到應該是因為我們一看就是觀光客，當地的好心人在烏漆嘛黑的路邊給看起來很無助的觀光客一點指引。（人好好）（愛心）\n我們在 KV 逛街的時候，遇到了此生最友善、最大方的櫃姐，她瘋狂提供我們小樣，還讓我們帶回去試用一個晚上，毫無施壓的 sales 技巧，不得不讓我們隔天回去買一堆產品。（佩服）\n飲食 飲料都沒什麼味道，像是 iced tea 以及這邊有名的 lemonade，顏色很鮮豔但喝起來實在很淡。另一方面食物都好鹹，像是吃薯泥的時候比較像在吃鹽巴佐馬鈴薯？\n再次強調，內陸飲食習慣大概就是肉肉天堂，我自己覺得跟德國比的話又更肉肉（在說什麼）。\n要不要換捷克克朗？ 第一天我換了 30€ 以免不時之需，約接近 800 CZK。結果 7 天的行程，只遇到一個小攤販不收刷卡，大部分的店不僅接受刷卡、還接受歐元現金支付。不過匯率可能沒有到很漂亮，最漂亮的應該是慕夏博物館，1:24，其他店家大部分有 23 就了不起了。\n所以需要的話頂多換小額，手邊持歐元的話甚至不用換匯也沒關係。\n結論 在很多地方都會覺得不像是出國，因為路上實在太多…台灣人了…。就是當你走在路上，旁邊有一群人講話超大聲，仔細一聽發現這是熟悉的語言、甚至是熟悉的口音，不禁覺得有點好笑。然後還有聽到一些白目言論，不禁感嘆出國了也是要注意言行，不要因為語言不一樣就自以為可以肆無忌憚地批評另一個國家與文化呀。\n這次去捷克真的看到跟西歐完全不同的風土民情、以及令人嘆為觀止的物價。這讓我迫不及待安排去其他國家的行程！！如果有機會，也會很希望可以有機會二訪捷克。\n","date":"2024-01-13T15:55:39Z","image":"https://miyaya.github.io/p/%E4%B8%80%E9%80%B1%E6%8D%B7%E5%85%8B%E4%B9%8B%E6%97%85/1_hu_1c6d5be22088b0.jpg","permalink":"https://miyaya.github.io/p/%E4%B8%80%E9%80%B1%E6%8D%B7%E5%85%8B%E4%B9%8B%E6%97%85/","title":"一週捷克之旅"}]